# 七月

## 1日 最长重复子数组718

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

**示例：**

```
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```

**提示：**

- 1 <= len(A), len(B) <= 1000
- 0 <= A[i], B[i] < 100

**解法：**

注意是子数组而不是子序列，子数组是连续的。

```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int[][] dp = new int[A.length + 1][B.length + 1];
        int ans = 0;
        for (int i = 1; i < dp.length; i++) 
            for (int j = 1; j < dp[i].length; j++) {
                if (A[i - 1] == B[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                ans = Math.max(ans, dp[i][j]);
            }
        return ans;
    }
}
```

## 2日 有序矩阵中第K小的元素378

给定一个 `n x n` 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

**示例：**

```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```

**提示：**

- 你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。

**解法：**

使用两次二分

- 在矩阵的最小值到最大值的闭区间内找所求的值
- 通过计算矩阵中有几个数字小于等于mid确定上一点中的二分区间移动，这一步是对矩阵的每一行二分

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int width = matrix[0].length;
        int left = matrix[0][0], right = matrix[matrix.length - 1][width - 1];
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (count(matrix, mid) >= k) {  // 左侧边界的二分
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private int count(int[][] matrix, int target) {
        int width = matrix[0].length, cnt = 0;
        for (int i = 0; i < matrix.length; i++) {
            int left = 0, right = width;
            while(left < right) {   // 右侧边界的二分
                int mid = left + (right - left) / 2;
                if (matrix[i][mid] <= target) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            cnt += left;
        }
        return cnt;
    }
}
```

## 3日 将有序数组转换为二叉搜索树108

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

**示例:**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
      0
     / \
   -3   9
   /   /
 -10  5
```

**解法：**

使用递归，每次都将有序数组中的正中间的数字插入到BST中

```java
class Solution {
    int[] nums;

    public TreeNode sortedArrayToBST(int[] nums) {
        this.nums = nums;
        return recursion(0, nums.length - 1);
    }

    private TreeNode recursion(int left, int right) {
        if (left > right) return null;
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = recursion(left, mid - 1);
        node.right = recursion(mid + 1, right);
        return node;
    }
}
```

## 4日 最长有效括号32

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

**解法：**

使用栈检测括号，给不正确的括号值标志位，求连续无标志位的最大值

```java
class Solution {
    public int longestValidParentheses(String s) {
        Deque<Integer> stack = new LinkedList<>();
        boolean[] flags = new boolean[s.length()]; // true为错误的括号
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') stack.push(i);
            else {
                if (stack.isEmpty()) flags[i] = true;
                else stack.pop();
            }
        }
        while (!stack.isEmpty()) {
            flags[stack.pop()] = true;
        }
        int maxn = 0, len = 0;
        for (int i = 0; i < flags.length; i++) {
            if (flags[i] == false) len++;
            else {
                maxn = Math.max(len, maxn);
                len = 0;
            }
        }
        return Math.max(len, maxn);
    }
}
```

## 5日 通配符匹配44

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

两个字符串完全匹配才算匹配成功。

**说明:**

- s 可能为空，且只包含从 a-z 的小写字母。
- p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

**示例 3:**

```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

**示例 4:**

```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

**解法：**

状态：s 的前 i 个字符是否能和 p 的前 i 个字符匹配

转移：![](img/54.png)

base case：`dp[0][0] = true`， `dp[i][开头的若干个星号] = true`注意只有开头的连续星号才需要置为true，字母后面的星号就不需要了。

以示例4为例的 dp 数组：

|      | ""   | *    | a    | *    | b    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| ""   | T    | T    |      |      |      |
| a    |      | T    | T    | T    |      |
| d    |      | T    |      | T    |      |
| c    |      | T    |      | T    |      |
| e    |      | T    |      | T    |      |
| b    |      | T    |      | T    | T    |

```java
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        for (int i = 1; i <= p.length(); i++) {
            if (p.charAt(i - 1) == '*') dp[0][i] = true;
            else break;
        }
        dp[0][0] = true;
        
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= p.length(); j++) {
                if (p.charAt(j - 1) == '?') dp[i][j] = dp[i - 1][j - 1];
                else if (p.charAt(j - 1) == '*') 
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j - 1] && s.charAt(i - 1) == p.charAt(j - 1);
            }
        }
        return dp[s.length()][p.length()];
    }    
}
```

## 6日 不同路径II63

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![](img/55.png)

网格中的障碍物和空位置分别用 1 和 0 来表示。

**说明：**m 和 n 的值均不超过 100。

**示例 1:**

```
  输入:
  [
    [0,0,0],
    [0,1,0],
    [0,0,0]
  ]
  输出: 2
  解释:
  3x3 网格的正中间有一个障碍物。
  从左上角到右下角一共有 2 条不同的路径：
  1. 向右 -> 向右 -> 向下 -> 向下
  2. 向下 -> 向下 -> 向右 -> 向右
```

 **解法：**

首先想到回溯：

```java
class Solution {
    int res;

    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid.length == 0) return 0;
        if (obstacleGrid[0][0] == 1) return 0;
        backTrack(obstacleGrid, 0, 0);
        return res;
    }
    
    private void backTrack(int[][] grid, int i, int j) {
        if (i == grid.length-1 && j == grid[0].length-1 && grid[i][j] != 1) {
            res++;
            return;
        }
        if (i < grid.length - 1 && grid[i + 1][j] != 1) {
            i = i + 1;
            backTrack(grid, i, j);
            i = i - 1;
        }
        if (j < grid[0].length - 1 && grid[i][j + 1] != 1) {
            j = j + 1;
            backTrack(grid, i, j);
            j = j - 1;
        }
    }
}
```

然而超时，改用dp，状态是`dp[i][j] = 到答i行j列的路线个数`

转移：![](img/56.png)

实现（通过）：

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int dp[][] = new int[obstacleGrid.length+1][obstacleGrid[0].length+1];
        dp[0][1] = 1;
        for (int i = 1; i < dp.length; i++)
            for (int j = 1; j < dp[0].length; j++) {
                if (obstacleGrid[i - 1][j - 1] == 1) dp[i][j] = 0;
                else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        return dp[obstacleGrid.length][obstacleGrid[0].length];
    }
}
```

## 7日 路径总和112

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:** 
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

**解法：**

使用递归

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) return false;
        return recursion(root, sum);
    }

    private boolean recursion(TreeNode root, int sum) {
        if (root == null && sum == 0) return true;
        if (root == null && sum != 0) return false;
        if (root.left == null && root.right == null) return root.val == sum;
        int s = sum - root.val;
        return hasPathSum(root.left, s) || hasPathSum(root.right, s);
    }
}
```

## 8日 跳水版 面试题16.11

你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。

返回的长度需要从小到大排列。

**示例：**

```
输入：
shorter = 1
longer = 2
k = 3
输出： {3,4,5,6}
```

**提示：**

- 0 < shorter <= longer
- 0 <= k <= 100000

**解法：**

边界条件：

- k == 0时 返回空数组
- longer == shorter时 返回的数组只有一个元素，就是`shorter * k`。

只需要考虑shorter，shorter可以是`0 ~ k`个，就是`k + 1`种情况。

```java
class Solution {
    public int[] divingBoard(int shorter, int longer, int k) {
        if (k == 0) return new int[0];
        if (shorter == longer) {
            int[] arr = new int[1];
            arr[0] = shorter * k;
            return arr;
        }
        int[] res = new int[k + 1];
        for (int i = 0; i <= k ; i++) {
            res[i] = longer * i + shorter * (k - i);
        }
        return res;
    }
}
```

## 9日 恢复空格 面试题17.13

哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子"I reset the computer. It still didn’t boot!"已经变成了"iresetthecomputeritstilldidntboot"。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。

**注意：**本题相对原题稍作改动，只需返回未识别的字符数

**示例：**

```
输入：
dictionary = ["looked","just","like","her","brother"]
sentence = "jesslookedjustliketimherbrother"
输出： 7
解释： 断句后为"jess looked just like tim her brother"，共7个未识别字符。
```

**提示：**

- 0 <= len(sentence) <= 1000
- dictionary中总字符数不超过 150000。
- 你可以认为dictionary和sentence中只包含小写字母。

**解法：**

状态：dp[i] 是sentence 字符串的 [0, i) 范围内匹配不了的字符数

转移：用 sentence 字符串的[j, i)子串和字典匹配，j 的范围是 [0, i)

- 如果不匹配，增加了一个匹配不了的字符 `dp[i] = dp[i - 1]  + 1`。先考虑这种情况
- 如果匹配，则考虑是否值得匹配`dp[i] = Math.max(dp[j], dp[i])`。

```java
class Solution {
    public int respace(String[] dictionary, String sentence) {
        Set<String> set = new HashSet(Arrays.asList(dictionary));
        int n = sentence.length();
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1] + 1;
            for (int j = 0; j < i; j++) {
                if (set.contains(sentence.substring(j, i))) {
                    dp[i] = Math.min(dp[i], dp[j]);
                }
            }
        }
        return dp[n];
    }
}
```

时间复杂度为O($n^2$) 832ms，可以使用字典树优化，优化后复杂度仍为O($n^2$) ，但执行时间缩短到16ms，原因是在内层循环中增加了中途退出循环的可能，这正是字典树的作用，这里的字典树是倒序的。

```java
class Tire {
    public Tire[] next;
    public boolean isEnd;

    public Tire() {
        next = new Tire[26];
        isEnd = false;
    }

    public void insert(String s) {
        Tire curPos = this;

        for (int i = s.length() - 1; i >= 0; i--) {
            int t = s.charAt(i) - 'a';
            if (curPos.next[t] == null) {
                curPos.next[t] = new Tire();
            }
            curPos = curPos.next[t];
        }
        curPos.isEnd = true;
    }
}

class Solution {
    public int respace(String[] dictionary, String sentence) {
        Tire root = new Tire();
        for (String s : dictionary) {
            root.insert(s);
        }
        int n = sentence.length();
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1] + 1;
            Tire curPos = root;
            for (int j = i; j >= 1; j--) {
                int t = sentence.charAt(j - 1) - 'a';
                if (curPos.next[t] == null) break;  // 匹配不到
                else if (curPos.next[t].isEnd)    // 匹配到
                	// 注意这里是j-1, 匹配到的单词第一个字符在j，j-1表这个单词之前
                    dp[i] = Math.min(dp[j - 1], dp[i]);
                else if (dp[i] == 0) break;         // 完全匹配
                curPos = curPos.next[t];
            }
        }
        return dp[n];
    }
}
```

## 10日 最佳买卖股票时机含冷冻期309

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**解法：**

dp，第一维表示第几天，第二维表示买入或卖出。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 0) return 0;
        int[][] dp = new int[prices.length][2];
        dp[0][1] = -prices[0];
        for (int i = 1; i < dp.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            if (i >= 2)
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
            else 
                dp[i][1] = Math.max(dp[i - 1][1], 0 - prices[i]);
        }
        return dp[dp.length - 1][0];
    }
}
```

## 11日 计算右侧小于当前元素的个数315

给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。

**示例:**

```
输入: [5,2,6,1]
输出: [2,1,1,0] 
解释:
5 的右侧有 2 个更小的元素 (2 和 1).
2 的右侧仅有 1 个更小的元素 (1).
6 的右侧有 1 个更小的元素 (1).
1 的右侧有 0 个更小的元素.
```

**解法：**

使用离散化的树状数组

```java
class Solution {
    private int[] a;
    private int[] c;

    public List<Integer> countSmaller(int[] nums) {
        List<Integer> res = new LinkedList<>();
        discretization(nums);
        this.c = new int[a.length];
        for (int i = nums.length - 1; i >= 0; i--) {
            int idx = getIndex(nums[i]);
            res.add(getSum(idx - 1));
            update(idx);
        }
        Collections.reverse(res);
        return res;
    }

    private void discretization(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int n : nums) set.add(n);
        this.a = new int[set.size() + 1];
        int index = 1;
        for (Integer n : set) a[index++] = n.intValue();
        Arrays.sort(a, 1, a.length);
    }

    private int getIndex(int num) {
        return Arrays.binarySearch(a, 1, a.length, num);
    }

    private int lowBit(int x) {
        return x & (-x);
    }

    private int getSum(int n) {
        int res = 0;
        while (n > 0) {
            res += c[n];
            n -= lowBit(n);
        }
        return res;
    }

    private void update(int idx) {
        while (idx < c.length) {
            c[idx]++;
            idx += lowBit(idx);
        }
    }
}
```

## 12日 地下城游戏174

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

-2 (K)	-3	3
-5	-10	1
10	30	-5 (P)


说明:

- 骑士的健康点数没有上限。

- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。


**解法：**

反向dp，`dp[i][j]`就是骑士在第 i 行 j 列所需要的最小hp，所以这个值是不能小于 1 的。

初值，其实到公主房间前的最低HP

```java
dp[row - 1][col - 1] = Math.max(1 - dungeon[row-1][col-1], 1);
```

对于最后一列和最后一行，只能仅向下或仅向右，所以转移是：

```java
for (int i = row - 2; i >= 0; i--)
    dp[i][col - 1] = Math.max(dp[i+1][col-1] - dungeon[i][col-1], 1);
for (int i = col - 2; i >= 0; i--)
    dp[row - 1][i] = Math.max(dp[row-1][i+1] - dungeon[row-1][i], 1);
for (int i = row - 2; i >= 0; i--)
```

其他格子的转移就是选去右边或去下边需要的最小HP，并且减去这一格需要的HP

```java
for (int i = row - 2; i >= 0; i--)
    for (int j = col - 2; j >= 0; j--) {
        dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1])-dungeon[i][j];
        if (dp[i][j] < 1) dp[i][j] = 1;
    }
```

完整代码：

```java
class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        int row = dungeon.length, col = dungeon[0].length;
        int[][] dp = new int[row][col];
        dp[row - 1][col - 1] = Math.max(1 - dungeon[row-1][col-1], 1);
        for (int i = row - 2; i >= 0; i--)
            dp[i][col - 1] = Math.max(dp[i+1][col-1] - dungeon[i][col-1], 1);
        for (int i = col - 2; i >= 0; i--)
            dp[row - 1][i] = Math.max(dp[row-1][i+1] - dungeon[row-1][i], 1);
        for (int i = row - 2; i >= 0; i--)
            for (int j = col - 2; j >= 0; j--) {
                dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1])-dungeon[i][j];
                if (dp[i][j] < 1) dp[i][j] = 1;
            }
        return dp[0][0];
    }
}
```

## 13日 两个数组的交集II 350

给定两个数组，编写一个函数来计算它们的交集。

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**示例 2:**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

**说明：**

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
- 我们可以不考虑输出结果的顺序。

**进阶：**

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 nums1 的大小比 nums2 小很多，哪种方法更优？
- 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

**解法：**

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        // 将nums1的 数字-出现次数 装入map
        Map<Integer, Integer> map = new HashMap<>();
        // getOrdefault(key, defaultValue)
        for (int num : nums1)
            map.put(num, map.getOrDefault(num, 0) + 1);

        // 遍历nums2，每找到一个： 1加入结果集，2在map中value - 1
        ArrayList<Integer> list = new ArrayList<>();
        for (int num : nums2)
            if (map.containsKey(num) && map.get(num) > 0) {
                list.add(num);
                map.put(num, map.get(num) - 1);
            }

        // 返回结果
        int[] res = new int[list.size()];
        for (int i = 0; i < list.size(); i++)
            res[i] = list.get(i);
        return res;
    }
}
```

## 14日 三角形最小路径和 120

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 `下标` 与 `上一层结点下标` 相同或者等于 `上一层结点下标 + 1` 的两个结点。

例如，给定三角形：

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

**说明：**

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

**解法：**

`dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + 三角形[i][j]`再优化成一维的dp数组

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        if (triangle.size() == 0) return 0;
        int[] dp = new int[triangle.size()];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = triangle.get(0).get(0);
        for (int i = 1; i < triangle.size(); i++) {
            for (int j = i; j >= 0; j--) {
                if (j == 0) dp[j] = dp[j] + triangle.get(i).get(j);
                else dp[j] = Math.min(dp[j], dp[j - 1]) 
                        + triangle.get(i).get(j);
            }
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < dp.length; i++) {
            res = Math.min(res, dp[i]);
        }
        return res;
    }
}
```

## 15日 不同的二叉搜索树 96

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

**解法：**

假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，...，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得`G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)`。

```java
class Solution {
    public int numTrees(int n) {
        if (n == 0) return 0;
        int[] dp = new int[n + 1];
        dp[0] = dp[1] = 1;
        for (int i = 2; i < dp.length; i++) {
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        return dp[n];
    }
}
```

## 16日 判断二分图 785

给定一个无向图graph，当这个图为二分图时返回true。

如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。

graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。

**示例 1:**

```
输入: [[1,3], [0,2], [1,3], [0,2]]
输出: true
解释: 
无向图如下:
0----1
|    |
|    |
3----2
我们可以将节点分成两组: {0, 2} 和 {1, 3}。
```

**示例 2:**

```
输入: [[1,2,3], [0,2], [0,1,3], [0,2]]
输出: false
解释: 
无向图如下:
0----1
| \  |
|  \ |
3----2
我们不能将节点分割成两个独立的子集。
```

**注意:**

- graph 的长度范围为 [1, 100]。
- graph[i] 中的元素的范围为 [0, graph.length - 1]。
- graph[i] 不会包含 i 或者有重复的值。
- 图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。

**解法：**

给初始结点标红色，红色的相邻结点标绿色，绿色的相邻标红色，如果颜色冲突，则不是二分图。

注意题目中的图不一定联通，所以需要多次bfs

```java
class Solution {
    private int color[];    // 0代表位访问到 1代表涂红 2代表涂绿
    private boolean isVaild;

    public boolean isBipartite(int[][] graph) {
        this.color = new int[graph.length];
        isVaild = true;
        for (int i = 0; i < graph.length; i++) {
            if (color[i] == 0) dfs(i, 1, graph);
        }
        return isVaild;
    }

    private void dfs(int node, int c, int[][] graph) {
        color[node] = c;
        int neighborColor = (c == 1) ? 2 : 1;
        for (int neighbor : graph[node]) {
            if (color[neighbor] == 0) {
                dfs(neighbor
                , neighborColor, graph);
                if (!isVaild) return;
            }
            else if (color[neighbor] != neighborColor) {
                isVaild = false;
                return;
            }
        }
    }
}
```

## 17日 搜索插入位置 35

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**

```
输入: [1,3,5,6], 5
输出: 2
```

**示例 2:**

```
输入: [1,3,5,6], 2
输出: 1
```

**示例 3:**

```
输入: [1,3,5,6], 7
输出: 4
```

**示例 4:**

```
输入: [1,3,5,6], 0
输出: 0
```

**解法：**

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target)
                right = mid - 1;
            else if (nums[mid] < target)
                left = mid + 1;
        }
        return left;
    }
}
```

## 18日 交错字符串 97

给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。

**示例 1:**

```
输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出: true
```

**示例 2:**

```
输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
输出: false
```

**解法：**

递归/搜索

```java
class Solution {
    String s1, s2, s3;

    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        this.s1 = s1;
        this.s2 = s2;
        this.s3 = s3;
        return recursion(0,0,0);
    }

    private boolean recursion(int i1, int i2, int i3) {
        if (i1 == s1.length() && i2 == s2.length() && i3 == s3.length())
            return true;
        boolean res = false;
        if (i1 < s1.length() && s1.charAt(i1) == s3.charAt(i3) && recursion(i1 + 1, i2, i3 + 1)) return true;
        if (i2 < s2.length() && s2.charAt(i2) == s3.charAt(i3) && recursion(i1, i2 + 1, i3 + 1)) return true;
        return res;
    }
}
```

记忆化：Boolean可以有三种状态true false null

```java
class Solution {
    String s1, s2, s3;
    Boolean[][] dp;

    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        this.s1 = s1;
        this.s2 = s2;
        this.s3 = s3;
        this.dp = new Boolean[s1.length() + 1][s2.length() + 1];
        return recursion(0,0,0);
    }

    private boolean recursion(int i1, int i2, int i3) {
        if (i1 == s1.length() && i2 == s2.length() && i3 == s3.length())
            return true;
        if (dp[i1][i2] != null) return dp[i1][i2];
        boolean res = false;
        if (i1 < s1.length() && s1.charAt(i1) == s3.charAt(i3) && recursion(i1 + 1, i2, i3 + 1)) {
            dp[i1][i2] = true;
            return true;           
        }
        if (i2 < s2.length() && s2.charAt(i2) == s3.charAt(i3) && recursion(i1, i2 + 1, i3 + 1)) {
            dp[i1][i2] = true;
            return true;
        }
        dp[i1][i2] = false;
        return res;
    }
}
```

动态规划：

状态：`dp[i][j]`就是 s1 的前 i 个字符和 s2 的前 j 个字符，能否交错组成 s3 的前 i + j 个字符

转移：![](img/68.png)

basecase: `dp[0][0] = true` 空串和空串能交错组成空串

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
        dp[0][0] = true;
        for (int i = 0; i <= s1.length(); i++)
            for (int j = 0; j <= s2.length(); j++) {
                int i3 = i + j - 1;
                if (i != 0) 
                    dp[i][j] |= dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i3);
                if (j != 0) 
                    dp[i][j] |= dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i3);
            }
        return dp[s1.length()][s2.length()];
    }
}
```

## 19日 戳气球 312

有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

**说明:**

- 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
- 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100

**示例:**

```
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

**解法：**

每戳破一个气球，nums数组就会改变，看似子问题不独立，但是，求最值问题一定可以穷举得到结果。

状态：i 和 j 本身就是状态，表示起始的气球和中止的气球。

转移：戳破 i 和 j 之间即（i，j）中的一个气球。

`dp[i][j]`表示把 i ，j 开区间内的所有气球戳爆获得的最大钱数。题目中说可以假设`nums[-1] = nums[n] = 1`，所以`dp[-1][n]`就是最终答案。

状态转移方程：`dp[i][j] = dp[i][k] + dp[k][j] + nums[i] * nums[j] * nums[k]`。

只需要用到上三角矩阵，而且是从下往上dp的。

![](E:/kejian/知识总结/leetcode/img/46.jpeg)

```java
class Solution {
    public int maxCoins(int[] nums) {
        int len = nums.length;
        int[] points = new int[len + 2];
        points[0] = points[len + 1] = 1;
        for (int i = 1; i <= len; i++) points[i] = nums[i - 1];
        int[][] dp = new int[len + 2][len + 2];
        for (int i = len; i >= 0; i--) {
            for (int j = i + 1; j < len + 2; j++) {
                for (int k = i + 1; k < j; k++) {
                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + points[i] * points[k] * points[j]); 
                }
            }
        }
        return dp[0][len + 1];
    }
}
```

## 20日 两数之和II-输入有序数组167

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例:**

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**解法：**

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int[] res = new int[2];
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            if (numbers[left] + numbers[right] < target) left++;
            else if (numbers[left] + numbers[right] > target) right--;
            else {
                res[0] = left + 1;
                res[1] = right + 1;
                break;
            }
        }
        return res;
    }
}
```

## 21日 不同的二叉搜索树II 95

给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。

**示例：**

```
输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

**提示：**

- 0 <= n <= 8

**解法：**

注意这不是回溯，是递归，链表定义在每一层递归的开头。

```java
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if (n == 0) return new LinkedList<TreeNode>();
        return recursion(1, n);
    }

    // 求[start, end]范围内所有节点构造出的所有子树
    private List<TreeNode> recursion(int start, int end) {
        // 当前子树的所有可能的排列
        List<TreeNode> allTrees = new LinkedList<>();
        if (start > end) {
            allTrees.add(null); // 这一句是必须的，否则创建不了结点
            return allTrees;
        }

        for (int i = start; i <= end; i++) {
            // 当前子树的左子树和右子树的所有可能的排列
            List<TreeNode> leftTrees = recursion(start, i - 1);
            List<TreeNode> rightTrees = recursion(i + 1, end);

            // 构建出当前子树所有可能的排列
            for (TreeNode left : leftTrees)
                for (TreeNode right : rightTrees) {
                    TreeNode node = new TreeNode(i);
                    node.left = left;
                    node.right = right;
                    allTrees.add(node);
                }
        }

        return allTrees;
    }
}
```

## 22日 旋转数组的最小数字 剑指offer11

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

**示例 1：**

```
输入：[3,4,5,1,2]
输出：1
```

**示例 2：**

```
输入：[2,2,2,0,1]
输出：0
```

**解法：**

```java
class Solution {
    public int minArray(int[] numbers) {
        int left = 0, right = numbers.length - 1;
        while (numbers[left] >= numbers[right]) {
            if (left == right - 1) {
                return numbers[right];
            }
            int mid = left + (right - left) / 2;
            if (numbers[left]==numbers[right]&&numbers[left]==numbers[mid]) {
                return inorderSearch(numbers, left, right);
            }
            if (numbers[mid] >= numbers[left])
                left = mid;
            else if (numbers[mid] <= numbers[right])
                right = mid; 
        }
        return numbers[left];
    }

    private int inorderSearch(int[] numbers, int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            if (numbers[i] < numbers[i - 1]) {
                return numbers[i];
            }
        }
        return numbers[left];
    }
}
```

## 23日 最小路径和64

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

**示例:**

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

**解法：**

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) return 0;
        int row = grid.length, col = grid[0].length;
        for (int i = 1; i < row; i++)
            grid[i][0] += grid[i - 1][0];
        for (int i = 1; i < col; i++)
            grid[0][i] += grid[0][i - 1];
        for (int i = 1; i < row; i++)
            for (int j = 1; j < col; j++) {
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        return grid[row - 1][col - 1];
    }
}
```

## 24日 除数博弈1025

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

选出任一 x，满足 0 < x < N 且 N % x == 0 。
用 N - x 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

**示例 1：**

```
输入：2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
```

**示例 2：**

```
输入：3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
```

**提示：**

- 1 <= N <= 1000

**解法：**

多列几项找规律可知，偶数先手必胜

```java
class Solution {
    public boolean divisorGame(int N) {
        if (N % 2 == 0) return true;
        return false;
    }
}
```

## 25日 分割数组的最大值410

给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。

**注意:**
数组长度 n 满足以下条件:

- 1 ≤ n ≤ 1000
- 1 ≤ m ≤ min(50, n)

**示例:**

```
输入:
nums = [7,2,5,10,8]
m = 2

输出:
18

解释:
一共有四种方法将nums分割为2个子数组。
其中最好的方式是将其分为[7,2,5] 和 [10,8]，
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小
```

**解法：**

```java
class Solution {
    public int splitArray(int[] nums, int m) {
        // 子数组和 可能的范围是 最大值 到 总和
        long left = 0, right = 0;
        int n = nums.length;
        for (int i : nums) {
            if (i > left) left = i;
            right += i;
        }
        // 在这个范围内找到能把数组分为n个子数组的最大值
        long ans = right;
        while (left <= right) {  // 二分
            long mid = left + (right - left) / 2;
            long sum = 0;   // 单个子数组的和
            long cnt = 1;   // 子数组的数量
            for (int i = 0; i < n; i++) {
                if (sum + nums[i] > mid) {
                    cnt++;
                    sum = nums[i];
                } else {
                    sum += nums[i];
                }
            }
            if (cnt <= m) { // 这一步保证找到最小的mid
                ans = Math.min(ans, mid);
                right = mid - 1;
            } else left = mid + 1;
        }
        return (int) ans;
    }
}
```

## 26日 矩阵中的最长递增路径

给定一个整数矩阵，找出最长递增路径的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。

**示例 1:**

```
输入: nums = 
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 
输出: 4 
解释: 最长递增路径为 [1, 2, 6, 9]。
```

**示例 2:**

```
输入: nums = 
[
  [3,4,5],
  [3,2,6],
  [2,2,1]
] 
输出: 4 
解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
```

**解法：**

记忆化dfs

```java
class Solution {
    Integer[][] memo;

    public int longestIncreasingPath(int[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) return 0;
        int res = 0;
        memo = new Integer[matrix.length][matrix[0].length];
        for (int i = 0; i < matrix.length; i++)
            for (int j = 0; j < matrix[0].length; j++) {
                res = Math.max(res, dfs(matrix, i, j, Long.MAX_VALUE));
            }
        return res;
    }

    int dfs(int[][] matrix, int x, int y, long last) {
        if (x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length || matrix[x][y] >= last) return 0;
        if (memo[x][y] != null) return memo[x][y];
        int step = dfs(matrix, x - 1, y, matrix[x][y]) + 1;
        step = Math.max(step, dfs(matrix, x + 1, y, matrix[x][y]) + 1);
        step = Math.max(step, dfs(matrix, x, y - 1, matrix[x][y]) + 1);
        step = Math.max(step, dfs(matrix, x, y + 1, matrix[x][y]) + 1);
        memo[x][y] = step;
        return step;
    }
}
```

## 27日 判断子序列392

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

**示例 1:**

```
s = "abc", t = "ahbgdc"
返回 true.
```

**示例 2:**

```
s = "axc", t = "ahbgdc"
返回 false.
```

**解法：**

这道题问的是子序列而不是子串，不问是kmp，是问 s 是否在 t 中按顺序出现。

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        if (s == null || s.length() == 0) return true;
        char[] chars = s.toCharArray();
        int index = -1;
        for (char c : chars) {
            index = t.indexOf(c, index + 1);
            if (index == -1) return false;
        }
        return true;
    }
}
```

## 28日 二叉树的最大深度104

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**

```
给定二叉树 [3,9,20,null,null,15,7]，

    3

   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

**解法：**

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
```

## 29日 寻宝LCP13

我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。

迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 'S' 表示），和唯一的宝藏地点（用 'T' 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 'M' 表示），只有所有机关均被触发，才可以拿到宝藏。

要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 'O' 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。

迷宫中同样有一些墙壁（用 '#' 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 '.' 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。

我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。

**示例 1：**

```
输入： ["S#O", "M..", "M.T"]

输出：16

解释：最优路线为： S->O, cost = 4, 去搬石头 O->第二行的M, cost = 3, M机关触发 第二行的M->O, cost = 3, 我们需要继续回去 O 搬石头。 O->第三行的M, cost = 4, 此时所有机关均触发 第三行的M->T, cost = 2，去T点拿宝藏。 总步数为16。
```

![](img/72.gif)

**解法：**

bfs + dp

bfs算出起点到机关的距离（起点 - 石头 - 机关），机关到机关的距离（机关 - 石头 - 机关），机关到终点的距离（机关 - 终点）

dp是二维数组，$2^n$ 列，按位标记，比如5（101）就是去过第1个机关和第三个机关；n行，表示现在在第几个机关。n是机关数。

转移：![](img/73.png)

basecase:  站在第一个机关上时，路程是起点到第一个机关的距离。

```java
for (int i = 0; i < buttons.size(); i++)
	dp[1 << i][i] = dist[i][buttons.size()];
```

完整代码：

```java
class Solution {
    int[] dx = {1, -1, 0, 0};
    int[] dy = {0, 0, 1, -1};
    int row, col;

    public int minimalSteps(String[] maze) {
        this.row = maze.length;
        this.col = maze[0].length();
        List<int[]> buttons = new ArrayList<>();// 机关
        List<int[]> stones = new ArrayList<>(); // 石头
        int sx = -1, sy = -1;   // 起点
        int ex = -1, ey = -1;   // 终点
        // 初始化机关 石头 起点 终点
        for (int i = 0; i < row; i++)
            for (int j = 0; j < col; j++) {
                if (maze[i].charAt(j) == 'M')
                    buttons.add(new int[]{i, j});
                else if (maze[i].charAt(j) == 'O')
                    stones.add(new int[]{i, j});
                else if (maze[i].charAt(j) == 'S') {
                    sx = i;
                    sy = j;
                } else if (maze[i].charAt(j) == 'T') {
                    ex = i;
                    ey = j;
                }
            }
        // 各点到起点的距离
        int[][] startDist = bfs(sx, sy, maze);
        // 没有机关时的特殊处理
        if (buttons.size() == 0) return startDist[ex][ey];
        // 从某个机关到其他机关/起点/终点的距离
        int[][] dist = new int[buttons.size()][buttons.size() + 2];
        // 每个机关到个点的距离
        int[][][] dd = new int[buttons.size()][row][col];
        for (int i = 0; i < buttons.size(); i++) {
            int[][] d = bfs(buttons.get(i)[0], buttons.get(i)[1], maze);
            dd[i] = d;  // 初始化dd
            // 初始化每个机关到终点的距离
            dist[i][buttons.size() + 1] = d[ex][ey];
        }
        // 初始化dist数组
        for (int i = 0; i < buttons.size(); i++) {
            int tmp = -1;
            // 求从起点 拿到石头 到机关i的最短距离
            for (int j = 0; j < stones.size(); j++) {
                int stonex = stones.get(j)[0];
                int stoney = stones.get(j)[1];
                if (dd[i][stonex][stoney] != -1 && startDist[stonex][stoney] != -1 && (tmp == -1 || tmp > dd[i][stonex][stoney] + startDist[stonex][stoney])) 
                tmp = dd[i][stonex][stoney] + startDist[stonex][stoney];
            }
            dist[i][buttons.size()] = tmp;
            // 求从当前机关i 拿到石头k 到下一机关j的最短距离
            for (int j = 0; j < buttons.size(); j++) {
                int minDistance = -1;
                for (int k = 0; k < stones.size(); k++) {
                    int stonex = stones.get(k)[0];
                    int stoney = stones.get(k)[1];
                    if (dd[i][stonex][stoney] != -1 && dd[j][stonex][stoney] != -1 && (minDistance == -1 || minDistance > dd[i][stonex][stoney] + dd[j][stonex][stoney])) 
                    minDistance = dd[i][stonex][stoney] + dd[j][stonex][stoney];
                }
                dist[i][j] = minDistance;
                dist[j][i] = minDistance;
            }
        }

        // 机关无法到达起点或终点时 返回-1
        for (int i = 0; i < buttons.size(); i++) {
            if (dist[i][buttons.size()] == -1 || dist[i][buttons.size() + 1] == -1)
            return -1;
        }
        // dp数组 第一维是机关数个二级制位，位为1表到过2为没到过
        // 第二维表示当前处于哪个机关
        int[][] dp = new int[1 << buttons.size()][buttons.size()];
        for (int i = 0; i < dp.length; i++)
            Arrays.fill(dp[i], -1);
        // 从起点到第一个机关的距离
        for (int i = 0; i < buttons.size(); i++)
            dp[1 << i][i] = dist[i][buttons.size()];
        for (int mask = 1; mask < (1 << buttons.size()); mask++) {
            for (int i = 0; i < buttons.size(); i++) {
                if ((mask & (1 << i)) != 0) {   // 机关i到过
                    for (int j = 0; j < buttons.size(); j++) {
                        if ((mask & (1 << j)) == 0) { // 机关j没到过
                            int next = mask | (1 << j);
                            if (dp[next][j] == -1 || dp[next][j] > dp[mask][i] + dist[i][j]) 
                            dp[next][j] = dp[mask][i] + dist[i][j];
                        }
                    }
                }
            }
        }
        // 计算结果
        int res = -1;
        int finalMask = (1 << buttons.size()) - 1;
        for (int i = 0; i < buttons.size(); i++) {
            if (res == -1 || res > dp[finalMask][i] + dist[i][buttons.size() + 1])
            res = dp[finalMask][i] + dist[i][buttons.size() + 1];
        }
        return res;
    }

    // 以x, y为起点，到每一个点的距离
    private int[][] bfs(int x, int y, String[] maze) {
        int[][] res = new int[row][col];
        for (int i = 0; i < row; i++)
            Arrays.fill(res[i], -1);
        res[x][y] = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{x, y});
        while (!queue.isEmpty()) {
            int[] p = queue.poll();
            int curx = p[0], cury = p[1];
            for (int i = 0; i < 4; i++) {
                int nextx = curx + dx[i];
                int nexty = cury + dy[i];
                if (nextx < 0 || nextx >= row || nexty < 0 || nexty >= col || maze[nextx].charAt(nexty) == '#' || res[nextx][nexty] != -1) continue;
                res[nextx][nexty] = res[curx][cury] + 1;
                queue.offer(new int[]{nextx, nexty});
            }
        }
        return res;
    }
}
```

## 30日 整数拆分343

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
说明: 你可以假设 n 不小于 2 且不大于 58。
```

**解法：**

这个问题和剑指offer14是相同的，有dp和贪心两种解法

状态：i >= 4时：dp[i] = 长度为 i 的绳子的最大乘积；i < 4 时 dp[i] = i
转移：dp[i] = max(dp[i - x] * dp[x])
base case: i < 4 时 dp[i] = i。dp[0]舍弃。因为当n < 4时，剪过的乘积小于本身的长度，而题目要求至少剪一刀

```java
class Solution {
    public int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;
        for (int i = 4; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = Math.max(dp[i], dp[j] * dp[i - j]);
            }
        }
        return dp[n];
    }
}
```

贪心：

```java
class Solution {
    public int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        int num3 = n / 3;
        if (n - num3 * 3 == 1) num3--;
        int num2 = (n - num3 * 3) / 2;
        return (int)(Math.pow(3, num3) * Math.pow(2, num2));
    }
}
```

## 31日 魔术索引 面试题08.03

魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

**示例1:**

```
 输入：nums = [0, 2, 3, 4, 5]
 输出：0
 说明: 0下标的元素为0
```

**示例2:**

```
 输入：nums = [1, 1, 1]
 输出：1
```

**提示:**

- nums长度在[1, 1000000]之间


**解法：**

```java
class Solution {
    public int findMagicIndex(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == i) return i;
        }
        return -1;
    }
}
```

# 8月

## 1日 最小区间 632

你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。

我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小。

**示例 1:**

```
输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
输出: [20,24]
解释: 
列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。
列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。
列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。
```

**注意:**

- 给定的列表可能包含重复元素，所以在这里升序表示 >= 。
- 1 <= k <= 3500
- -105 <= 元素的值 <= 105

**解法：**

维护一个优先队列，存的是每一个列表的下标，按照该下标对应的元素排序。

这样每次出队的都是队列中的最小元素，用最大元素减最小元素，就可以算出区间大小。

把最小元素对应列表的下标后移，入队继续。

```java
class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int size = nums.size();
        int[] indexs = new int[size];
        PriorityQueue<Integer> pq = new PriorityQueue<>((idx1, idx2) -> 
        (nums.get(idx1).get(indexs[idx1]) - nums.get(idx2).get(indexs[idx2])));
        int maxn = Integer.MIN_VALUE;
        for (int i = 0; i < size; i++) {
            pq.offer(i);
            maxn = Math.max(maxn, nums.get(i).get(0));
        }
        int rangeLeft = 0, rangeRight = 0;
        int minRange = Integer.MAX_VALUE;
        while (true) {
            int minIdx = pq.poll();
            int curRange = maxn - nums.get(minIdx).get(indexs[minIdx]);
            if (curRange < minRange) {
                minRange = curRange;
                rangeLeft = nums.get(minIdx).get(indexs[minIdx]);
                rangeRight = maxn;
            }
            indexs[minIdx] += 1;
            if (indexs[minIdx] >= nums.get(minIdx).size()) break;
            pq.offer(minIdx);
            maxn = Math.max(maxn, nums.get(minIdx).get(indexs[minIdx]));
        }
        return new int[]{rangeLeft, rangeRight};
    }
}
```

## 2日 二叉树展开为链表114

给定一个二叉树，原地将它展开为一个单链表。

例如，给定二叉树

```
    1
   / \
  2   5
 / \   \
3   4   6
```

将其展开为：

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

**解法：**

可以看出展开后是按前序排列的，可以在前序的基础上加一些修改操作。

先让前一个结点的右侧结点等于当前结点，而前一个结点的右侧结点已被保存在栈中。

最后别忘了让当前结点的左侧结点为空。

```java
class Solution {
    public void flatten(TreeNode root) {
        if (root == null) return;
        TreeNode pre = new TreeNode();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node = root;
        while (true) {
            while (node != null) {
                pre.right = node;
                stack.push(node.right);	// 前序
                pre = node;
                node = node.left;	// 前序
                pre.left = null;
            }
            if (stack.isEmpty()) break;
            node = stack.pop();
        }
    }
}
```

真正能原地的算法，当前结点如果有左子树，则把当前结点的右子树放到，左子树的最右边，再把当前结点的左子树变为右子树。

```java
class Solution {
    public void flatten(TreeNode root) {
        TreeNode cur = root;
        while (cur != null) {
            if (cur.left != null) {
                // 如果有左子树，当前结点的next应该是左子树的根节点
                TreeNode next = cur.left;
                TreeNode leftTail = next;
                while (leftTail.right != null) {
                    leftTail = leftTail.right;
                }
                // 当前结点的右子树放到左子树的最右边
                leftTail.right = cur.right;
                // 当前结点的左子树变为右子树
                cur.left = null;
                cur.right = next;
            }
            cur = cur.right;
        }
    }
}
```

## 3日 字符串相加415

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

**提示：**

- num1 和num2 的长度都小于 5100
- num1 和num2 都只包含数字 0-9
- num1 和num2 都不包含任何前导零
- 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式

**解法：**

```java
class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder sb = new StringBuilder();
        int jinwei = 0;
        int idx1 = num1.length(), idx2 = num2.length();
        while (idx1 > 0 && idx2 > 0) {
            idx1--; idx2--;
            int cur1 = num1.charAt(idx1) - '0';
            int cur2 = num2.charAt(idx2) - '0';
            int sum = cur1 + cur2 + jinwei;
            sb.append(sum % 10);
            jinwei = sum / 10;
        }
        while (idx1 > 0) {
            idx1--;
            int cur1 = num1.charAt(idx1) - '0';
            int sum = cur1 + jinwei;
            sb.append(sum % 10);
            jinwei = sum / 10;
        }
        while (idx2 > 0) {
            idx2--;
            int cur2 = num2.charAt(idx2) - '0';
            int sum = cur2 + jinwei;
            sb.append(sum % 10);
            jinwei = sum / 10;
        }
        if (jinwei != 0) sb.append(jinwei);
        return sb.reverse().toString();
    }
}
```

## 4日 课程表207

你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

**示例 1:**

```
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
```

**示例 2:**

```
输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

**提示：**

- 输入的先决条件是由 **边列表** 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。
- 你可以假定输入的先决条件中没有重复的边。
- 1 <= numCourses <= 10^5

**解法：**

这个问题的本质是在问有向图是否有拓扑排序，如果有环则不能拓扑排序。[官方题解](https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/)

基于dfs

```java
class Solution {
    List<List<Integer>> edges;
    Boolean[] visited;  // null未搜索false搜索中true搜索过
    boolean valid = true;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<>();
        for (int i = 0; i < numCourses; i++)
            edges.add(new ArrayList<>());
        visited = new Boolean[numCourses];
        for (int[] p : prerequisites) 
            edges.get(p[1]).add(p[0]);
        for (int i = 0; i < numCourses; i++) {
            if (visited[i] == null) dfs(i);
        }
        return valid;
    }

    private void dfs(int course) {
        visited[course] = false;
        for (int v : edges.get(course)) {
            if (visited[v] == null) {
                dfs(v);
                if(!valid) return;
            } else if (visited[v] == false) {
                valid = false;
                return;
            }
        }
        visited[course] = true;
        // 如果需要拓扑排序结果，就在这里进栈
    }
}
```

bfs

```java
class Solution {
    List<List<Integer>> edges;  // 邻接表
    int[] indegree; // 入度

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<>();
        indegree = new int[numCourses];
        for (int i = 0; i < numCourses; i++)
            edges.add(new ArrayList<>());
        for (int[] p : prerequisites) {
            edges.get(p[1]).add(p[0]);
            indegree[p[0]]++;
        }
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++)
            if (indegree[i] == 0) queue.offer(i);
        int visited = 0;
        while (!queue.isEmpty()) {
            ++visited;
            int u = queue.poll();
            for (int v : edges.get(u)) {
                indegree[v]--;
                if (indegree[v] == 0) queue.offer(v);
            }
        }
        return visited == numCourses;
    }
}
```

