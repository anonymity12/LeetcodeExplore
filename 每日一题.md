# 七月

## 1日 最长重复子数组718

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

**示例：**

```
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```

**提示：**

- 1 <= len(A), len(B) <= 1000
- 0 <= A[i], B[i] < 100

**解法：**

注意是子数组而不是子序列，子数组是连续的。

```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int[][] dp = new int[A.length + 1][B.length + 1];
        int ans = 0;
        for (int i = 1; i < dp.length; i++) 
            for (int j = 1; j < dp[i].length; j++) {
                if (A[i - 1] == B[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                ans = Math.max(ans, dp[i][j]);
            }
        return ans;
    }
}
```

## 2日 有序矩阵中第K小的元素378

给定一个 `n x n` 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

**示例：**

```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```

**提示：**

- 你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。

**解法：**

使用两次二分

- 在矩阵的最小值到最大值的闭区间内找所求的值
- 通过计算矩阵中有几个数字小于等于mid确定上一点中的二分区间移动，这一步是对矩阵的每一行二分

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int width = matrix[0].length;
        int left = matrix[0][0], right = matrix[matrix.length - 1][width - 1];
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (count(matrix, mid) >= k) {  // 左侧边界的二分
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private int count(int[][] matrix, int target) {
        int width = matrix[0].length, cnt = 0;
        for (int i = 0; i < matrix.length; i++) {
            int left = 0, right = width;
            while(left < right) {   // 右侧边界的二分
                int mid = left + (right - left) / 2;
                if (matrix[i][mid] <= target) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            cnt += left;
        }
        return cnt;
    }
}
```

## 3日 将有序数组转换为二叉搜索树108

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

**示例:**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
      0
     / \
   -3   9
   /   /
 -10  5
```

**解法：**

使用递归，每次都将有序数组中的正中间的数字插入到BST中

```java
class Solution {
    int[] nums;

    public TreeNode sortedArrayToBST(int[] nums) {
        this.nums = nums;
        return recursion(0, nums.length - 1);
    }

    private TreeNode recursion(int left, int right) {
        if (left > right) return null;
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = recursion(left, mid - 1);
        node.right = recursion(mid + 1, right);
        return node;
    }
}
```

## 4日 最长有效括号32

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

**解法：**

使用栈检测括号，给不正确的括号值标志位，求连续无标志位的最大值

```java
class Solution {
    public int longestValidParentheses(String s) {
        Deque<Integer> stack = new LinkedList<>();
        boolean[] flags = new boolean[s.length()]; // true为错误的括号
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') stack.push(i);
            else {
                if (stack.isEmpty()) flags[i] = true;
                else stack.pop();
            }
        }
        while (!stack.isEmpty()) {
            flags[stack.pop()] = true;
        }
        int maxn = 0, len = 0;
        for (int i = 0; i < flags.length; i++) {
            if (flags[i] == false) len++;
            else {
                maxn = Math.max(len, maxn);
                len = 0;
            }
        }
        return Math.max(len, maxn);
    }
}
```

## 5日 通配符匹配44

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

两个字符串完全匹配才算匹配成功。

**说明:**

- s 可能为空，且只包含从 a-z 的小写字母。
- p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

**示例 3:**

```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

**示例 4:**

```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

**解法：**

状态：s 的前 i 个字符是否能和 p 的前 i 个字符匹配

转移：![](img/54.png)

base case：`dp[0][0] = true`， `dp[i][开头的若干个星号] = true`注意只有开头的连续星号才需要置为true，字母后面的星号就不需要了。

以示例4为例的 dp 数组：

|      | ""   | *    | a    | *    | b    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| ""   | T    | T    |      |      |      |
| a    |      | T    | T    | T    |      |
| d    |      | T    |      | T    |      |
| c    |      | T    |      | T    |      |
| e    |      | T    |      | T    |      |
| b    |      | T    |      | T    | T    |

```java
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        for (int i = 1; i <= p.length(); i++) {
            if (p.charAt(i - 1) == '*') dp[0][i] = true;
            else break;
        }
        dp[0][0] = true;
        
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= p.length(); j++) {
                if (p.charAt(j - 1) == '?') dp[i][j] = dp[i - 1][j - 1];
                else if (p.charAt(j - 1) == '*') 
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j - 1] && s.charAt(i - 1) == p.charAt(j - 1);
            }
        }
        return dp[s.length()][p.length()];
    }    
}
```

## 6日 不同路径II63

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![](img/55.png)

网格中的障碍物和空位置分别用 1 和 0 来表示。

**说明：**m 和 n 的值均不超过 100。

**示例 1:**

```
  输入:
  [
    [0,0,0],
    [0,1,0],
    [0,0,0]
  ]
  输出: 2
  解释:
  3x3 网格的正中间有一个障碍物。
  从左上角到右下角一共有 2 条不同的路径：
  1. 向右 -> 向右 -> 向下 -> 向下
  2. 向下 -> 向下 -> 向右 -> 向右
```

 **解法：**

首先想到回溯：

```java
class Solution {
    int res;

    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid.length == 0) return 0;
        if (obstacleGrid[0][0] == 1) return 0;
        backTrack(obstacleGrid, 0, 0);
        return res;
    }
    
    private void backTrack(int[][] grid, int i, int j) {
        if (i == grid.length-1 && j == grid[0].length-1 && grid[i][j] != 1) {
            res++;
            return;
        }
        if (i < grid.length - 1 && grid[i + 1][j] != 1) {
            i = i + 1;
            backTrack(grid, i, j);
            i = i - 1;
        }
        if (j < grid[0].length - 1 && grid[i][j + 1] != 1) {
            j = j + 1;
            backTrack(grid, i, j);
            j = j - 1;
        }
    }
}
```

然而超时，改用dp，状态是`dp[i][j] = 到答i行j列的路线个数`

转移：![](img/56.png)

实现（通过）：

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int dp[][] = new int[obstacleGrid.length+1][obstacleGrid[0].length+1];
        dp[0][1] = 1;
        for (int i = 1; i < dp.length; i++)
            for (int j = 1; j < dp[0].length; j++) {
                if (obstacleGrid[i - 1][j - 1] == 1) dp[i][j] = 0;
                else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        return dp[obstacleGrid.length][obstacleGrid[0].length];
    }
}
```

## 7日 路径总和112

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:** 
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

**解法：**

使用递归

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) return false;
        return recursion(root, sum);
    }

    private boolean recursion(TreeNode root, int sum) {
        if (root == null && sum == 0) return true;
        if (root == null && sum != 0) return false;
        if (root.left == null && root.right == null) return root.val == sum;
        int s = sum - root.val;
        return hasPathSum(root.left, s) || hasPathSum(root.right, s);
    }
}
```

## 8日 跳水版 面试题16.11

你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。

返回的长度需要从小到大排列。

**示例：**

```
输入：
shorter = 1
longer = 2
k = 3
输出： {3,4,5,6}
```

**提示：**

- 0 < shorter <= longer
- 0 <= k <= 100000

**解法：**

边界条件：

- k == 0时 返回空数组
- longer == shorter时 返回的数组只有一个元素，就是`shorter * k`。

只需要考虑shorter，shorter可以是`0 ~ k`个，就是`k + 1`种情况。

```java
class Solution {
    public int[] divingBoard(int shorter, int longer, int k) {
        if (k == 0) return new int[0];
        if (shorter == longer) {
            int[] arr = new int[1];
            arr[0] = shorter * k;
            return arr;
        }
        int[] res = new int[k + 1];
        for (int i = 0; i <= k ; i++) {
            res[i] = longer * i + shorter * (k - i);
        }
        return res;
    }
}
```

## 9日 恢复空格 面试题17.13

哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子"I reset the computer. It still didn’t boot!"已经变成了"iresetthecomputeritstilldidntboot"。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。

**注意：**本题相对原题稍作改动，只需返回未识别的字符数

**示例：**

```
输入：
dictionary = ["looked","just","like","her","brother"]
sentence = "jesslookedjustliketimherbrother"
输出： 7
解释： 断句后为"jess looked just like tim her brother"，共7个未识别字符。
```

**提示：**

- 0 <= len(sentence) <= 1000
- dictionary中总字符数不超过 150000。
- 你可以认为dictionary和sentence中只包含小写字母。

**解法：**

状态：dp[i] 是sentence 字符串的 [0, i) 范围内匹配不了的字符数

转移：用 sentence 字符串的[j, i)子串和字典匹配，j 的范围是 [0, i)

- 如果不匹配，增加了一个匹配不了的字符 `dp[i] = dp[i - 1]  + 1`。先考虑这种情况
- 如果匹配，则考虑是否值得匹配`dp[i] = Math.max(dp[j], dp[i])`。

```java
class Solution {
    public int respace(String[] dictionary, String sentence) {
        Set<String> set = new HashSet(Arrays.asList(dictionary));
        int n = sentence.length();
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1] + 1;
            for (int j = 0; j < i; j++) {
                if (set.contains(sentence.substring(j, i))) {
                    dp[i] = Math.min(dp[i], dp[j]);
                }
            }
        }
        return dp[n];
    }
}
```

时间复杂度为O($n^2$) 832ms，可以使用字典树优化，优化后复杂度仍为O($n^2$) ，但执行时间缩短到16ms，原因是在内层循环中增加了中途退出循环的可能，这正是字典树的作用，这里的字典树是倒序的。

```java
class Tire {
    public Tire[] next;
    public boolean isEnd;

    public Tire() {
        next = new Tire[26];
        isEnd = false;
    }

    public void insert(String s) {
        Tire curPos = this;

        for (int i = s.length() - 1; i >= 0; i--) {
            int t = s.charAt(i) - 'a';
            if (curPos.next[t] == null) {
                curPos.next[t] = new Tire();
            }
            curPos = curPos.next[t];
        }
        curPos.isEnd = true;
    }
}

class Solution {
    public int respace(String[] dictionary, String sentence) {
        Tire root = new Tire();
        for (String s : dictionary) {
            root.insert(s);
        }
        int n = sentence.length();
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1] + 1;
            Tire curPos = root;
            for (int j = i; j >= 1; j--) {
                int t = sentence.charAt(j - 1) - 'a';
                if (curPos.next[t] == null) break;  // 匹配不到
                else if (curPos.next[t].isEnd)    // 匹配到
                	// 注意这里是j-1, 匹配到的单词第一个字符在j，j-1表这个单词之前
                    dp[i] = Math.min(dp[j - 1], dp[i]);
                else if (dp[i] == 0) break;         // 完全匹配
                curPos = curPos.next[t];
            }
        }
        return dp[n];
    }
}
```

## 10日 最佳买卖股票时机含冷冻期309

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**解法：**

dp，第一维表示第几天，第二维表示买入或卖出。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 0) return 0;
        int[][] dp = new int[prices.length][2];
        dp[0][1] = -prices[0];
        for (int i = 1; i < dp.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            if (i >= 2)
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
            else 
                dp[i][1] = Math.max(dp[i - 1][1], 0 - prices[i]);
        }
        return dp[dp.length - 1][0];
    }
}
```

## 11日 计算右侧小于当前元素的个数315

给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。

**示例:**

```
输入: [5,2,6,1]
输出: [2,1,1,0] 
解释:
5 的右侧有 2 个更小的元素 (2 和 1).
2 的右侧仅有 1 个更小的元素 (1).
6 的右侧有 1 个更小的元素 (1).
1 的右侧有 0 个更小的元素.
```

**解法：**

使用离散化的树状数组

```java
class Solution {
    private int[] a;
    private int[] c;

    public List<Integer> countSmaller(int[] nums) {
        List<Integer> res = new LinkedList<>();
        discretization(nums);
        this.c = new int[a.length];
        for (int i = nums.length - 1; i >= 0; i--) {
            int idx = getIndex(nums[i]);
            res.add(getSum(idx - 1));
            update(idx);
        }
        Collections.reverse(res);
        return res;
    }

    private void discretization(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int n : nums) set.add(n);
        this.a = new int[set.size() + 1];
        int index = 1;
        for (Integer n : set) a[index++] = n.intValue();
        Arrays.sort(a, 1, a.length);
    }

    private int getIndex(int num) {
        return Arrays.binarySearch(a, 1, a.length, num);
    }

    private int lowBit(int x) {
        return x & (-x);
    }

    private int getSum(int n) {
        int res = 0;
        while (n > 0) {
            res += c[n];
            n -= lowBit(n);
        }
        return res;
    }

    private void update(int idx) {
        while (idx < c.length) {
            c[idx]++;
            idx += lowBit(idx);
        }
    }
}
```

## 12日 地下城游戏174

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

-2 (K)	-3	3
-5	-10	1
10	30	-5 (P)


说明:

- 骑士的健康点数没有上限。

- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。


**解法：**

反向dp，`dp[i][j]`就是骑士在第 i 行 j 列所需要的最小hp，所以这个值是不能小于 1 的。

初值，其实到公主房间前的最低HP

```java
dp[row - 1][col - 1] = Math.max(1 - dungeon[row-1][col-1], 1);
```

对于最后一列和最后一行，只能仅向下或仅向右，所以转移是：

```java
for (int i = row - 2; i >= 0; i--)
    dp[i][col - 1] = Math.max(dp[i+1][col-1] - dungeon[i][col-1], 1);
for (int i = col - 2; i >= 0; i--)
    dp[row - 1][i] = Math.max(dp[row-1][i+1] - dungeon[row-1][i], 1);
for (int i = row - 2; i >= 0; i--)
```

其他格子的转移就是选去右边或去下边需要的最小HP，并且减去这一格需要的HP

```java
for (int i = row - 2; i >= 0; i--)
    for (int j = col - 2; j >= 0; j--) {
        dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1])-dungeon[i][j];
        if (dp[i][j] < 1) dp[i][j] = 1;
    }
```

完整代码：

```java
class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        int row = dungeon.length, col = dungeon[0].length;
        int[][] dp = new int[row][col];
        dp[row - 1][col - 1] = Math.max(1 - dungeon[row-1][col-1], 1);
        for (int i = row - 2; i >= 0; i--)
            dp[i][col - 1] = Math.max(dp[i+1][col-1] - dungeon[i][col-1], 1);
        for (int i = col - 2; i >= 0; i--)
            dp[row - 1][i] = Math.max(dp[row-1][i+1] - dungeon[row-1][i], 1);
        for (int i = row - 2; i >= 0; i--)
            for (int j = col - 2; j >= 0; j--) {
                dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1])-dungeon[i][j];
                if (dp[i][j] < 1) dp[i][j] = 1;
            }
        return dp[0][0];
    }
}
```

## 13日 两个数组的交集II 350

给定两个数组，编写一个函数来计算它们的交集。

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**示例 2:**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

**说明：**

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
- 我们可以不考虑输出结果的顺序。

**进阶：**

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 nums1 的大小比 nums2 小很多，哪种方法更优？
- 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

**解法：**

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        // 将nums1的 数字-出现次数 装入map
        Map<Integer, Integer> map = new HashMap<>();
        // getOrdefault(key, defaultValue)
        for (int num : nums1)
            map.put(num, map.getOrDefault(num, 0) + 1);

        // 遍历nums2，每找到一个： 1加入结果集，2在map中value - 1
        ArrayList<Integer> list = new ArrayList<>();
        for (int num : nums2)
            if (map.containsKey(num) && map.get(num) > 0) {
                list.add(num);
                map.put(num, map.get(num) - 1);
            }

        // 返回结果
        int[] res = new int[list.size()];
        for (int i = 0; i < list.size(); i++)
            res[i] = list.get(i);
        return res;
    }
}
```

## 14日 三角形最小路径和 120

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 `下标` 与 `上一层结点下标` 相同或者等于 `上一层结点下标 + 1` 的两个结点。

例如，给定三角形：

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

**说明：**

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

**解法：**

`dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + 三角形[i][j]`再优化成一维的dp数组

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        if (triangle.size() == 0) return 0;
        int[] dp = new int[triangle.size()];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = triangle.get(0).get(0);
        for (int i = 1; i < triangle.size(); i++) {
            for (int j = i; j >= 0; j--) {
                if (j == 0) dp[j] = dp[j] + triangle.get(i).get(j);
                else dp[j] = Math.min(dp[j], dp[j - 1]) 
                        + triangle.get(i).get(j);
            }
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < dp.length; i++) {
            res = Math.min(res, dp[i]);
        }
        return res;
    }
}
```

## 15日 不同的二叉搜索树 96

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

**解法：**

假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，...，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得`G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)`。

```java
class Solution {
    public int numTrees(int n) {
        if (n == 0) return 0;
        int[] dp = new int[n + 1];
        dp[0] = dp[1] = 1;
        for (int i = 2; i < dp.length; i++) {
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        return dp[n];
    }
}
```

## 16日 判断二分图 785

给定一个无向图graph，当这个图为二分图时返回true。

如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。

graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。

**示例 1:**

```
输入: [[1,3], [0,2], [1,3], [0,2]]
输出: true
解释: 
无向图如下:
0----1
|    |
|    |
3----2
我们可以将节点分成两组: {0, 2} 和 {1, 3}。
```

**示例 2:**

```
输入: [[1,2,3], [0,2], [0,1,3], [0,2]]
输出: false
解释: 
无向图如下:
0----1
| \  |
|  \ |
3----2
我们不能将节点分割成两个独立的子集。
```

**注意:**

- graph 的长度范围为 [1, 100]。
- graph[i] 中的元素的范围为 [0, graph.length - 1]。
- graph[i] 不会包含 i 或者有重复的值。
- 图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。

**解法：**

给初始结点标红色，红色的相邻结点标绿色，绿色的相邻标红色，如果颜色冲突，则不是二分图。

注意题目中的图不一定联通，所以需要多次bfs

```java
class Solution {
    private int color[];    // 0代表位访问到 1代表涂红 2代表涂绿
    private boolean isVaild;

    public boolean isBipartite(int[][] graph) {
        this.color = new int[graph.length];
        isVaild = true;
        for (int i = 0; i < graph.length; i++) {
            if (color[i] == 0) dfs(i, 1, graph);
        }
        return isVaild;
    }

    private void dfs(int node, int c, int[][] graph) {
        color[node] = c;
        int neighborColor = (c == 1) ? 2 : 1;
        for (int neighbor : graph[node]) {
            if (color[neighbor] == 0) {
                dfs(neighbor
                , neighborColor, graph);
                if (!isVaild) return;
            }
            else if (color[neighbor] != neighborColor) {
                isVaild = false;
                return;
            }
        }
    }
}
```

## 17日 搜索插入位置 35

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**

```
输入: [1,3,5,6], 5
输出: 2
```

**示例 2:**

```
输入: [1,3,5,6], 2
输出: 1
```

**示例 3:**

```
输入: [1,3,5,6], 7
输出: 4
```

**示例 4:**

```
输入: [1,3,5,6], 0
输出: 0
```

**解法：**

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target)
                right = mid - 1;
            else if (nums[mid] < target)
                left = mid + 1;
        }
        return left;
    }
}
```

## 18日 交错字符串 97

给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。

**示例 1:**

```
输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出: true
```

**示例 2:**

```
输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
输出: false
```

**解法：**

递归/搜索

```java
class Solution {
    String s1, s2, s3;

    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        this.s1 = s1;
        this.s2 = s2;
        this.s3 = s3;
        return recursion(0,0,0);
    }

    private boolean recursion(int i1, int i2, int i3) {
        if (i1 == s1.length() && i2 == s2.length() && i3 == s3.length())
            return true;
        boolean res = false;
        if (i1 < s1.length() && s1.charAt(i1) == s3.charAt(i3) && recursion(i1 + 1, i2, i3 + 1)) return true;
        if (i2 < s2.length() && s2.charAt(i2) == s3.charAt(i3) && recursion(i1, i2 + 1, i3 + 1)) return true;
        return res;
    }
}
```

记忆化：Boolean可以有三种状态true false null

```java
class Solution {
    String s1, s2, s3;
    Boolean[][] dp;

    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        this.s1 = s1;
        this.s2 = s2;
        this.s3 = s3;
        this.dp = new Boolean[s1.length() + 1][s2.length() + 1];
        return recursion(0,0,0);
    }

    private boolean recursion(int i1, int i2, int i3) {
        if (i1 == s1.length() && i2 == s2.length() && i3 == s3.length())
            return true;
        if (dp[i1][i2] != null) return dp[i1][i2];
        boolean res = false;
        if (i1 < s1.length() && s1.charAt(i1) == s3.charAt(i3) && recursion(i1 + 1, i2, i3 + 1)) {
            dp[i1][i2] = true;
            return true;           
        }
        if (i2 < s2.length() && s2.charAt(i2) == s3.charAt(i3) && recursion(i1, i2 + 1, i3 + 1)) {
            dp[i1][i2] = true;
            return true;
        }
        dp[i1][i2] = false;
        return res;
    }
}
```

动态规划：

状态：`dp[i][j]`就是 s1 的前 i 个字符和 s2 的前 j 个字符，能否交错组成 s3 的前 i + j 个字符

转移：![](img/68.png)

basecase: `dp[0][0] = true` 空串和空串能交错组成空串

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
        dp[0][0] = true;
        for (int i = 0; i <= s1.length(); i++)
            for (int j = 0; j <= s2.length(); j++) {
                int i3 = i + j - 1;
                if (i != 0) 
                    dp[i][j] |= dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i3);
                if (j != 0) 
                    dp[i][j] |= dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i3);
            }
        return dp[s1.length()][s2.length()];
    }
}
```

## 19日 戳气球 312

有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

**说明:**

- 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
- 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100

**示例:**

```
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

**解法：**

每戳破一个气球，nums数组就会改变，看似子问题不独立，但是，求最值问题一定可以穷举得到结果。

状态：i 和 j 本身就是状态，表示起始的气球和中止的气球。

转移：戳破 i 和 j 之间即（i，j）中的一个气球。

`dp[i][j]`表示把 i ，j 开区间内的所有气球戳爆获得的最大钱数。题目中说可以假设`nums[-1] = nums[n] = 1`，所以`dp[-1][n]`就是最终答案。

状态转移方程：`dp[i][j] = dp[i][k] + dp[k][j] + nums[i] * nums[j] * nums[k]`。

只需要用到上三角矩阵，而且是从下往上dp的。

![](E:/kejian/知识总结/leetcode/img/46.jpeg)

```java
class Solution {
    public int maxCoins(int[] nums) {
        int len = nums.length;
        int[] points = new int[len + 2];
        points[0] = points[len + 1] = 1;
        for (int i = 1; i <= len; i++) points[i] = nums[i - 1];
        int[][] dp = new int[len + 2][len + 2];
        for (int i = len; i >= 0; i--) {
            for (int j = i + 1; j < len + 2; j++) {
                for (int k = i + 1; k < j; k++) {
                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + points[i] * points[k] * points[j]); 
                }
            }
        }
        return dp[0][len + 1];
    }
}
```

## 20日 两数之和II-输入有序数组167

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例:**

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**解法：**

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int[] res = new int[2];
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            if (numbers[left] + numbers[right] < target) left++;
            else if (numbers[left] + numbers[right] > target) right--;
            else {
                res[0] = left + 1;
                res[1] = right + 1;
                break;
            }
        }
        return res;
    }
}
```

## 21日 不同的二叉搜索树II 95

给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。

**示例：**

```
输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

**提示：**

- 0 <= n <= 8

**解法：**

注意这不是回溯，是递归，链表定义在每一层递归的开头。

```java
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if (n == 0) return new LinkedList<TreeNode>();
        return recursion(1, n);
    }

    // 求[start, end]范围内所有节点构造出的所有子树
    private List<TreeNode> recursion(int start, int end) {
        // 当前子树的所有可能的排列
        List<TreeNode> allTrees = new LinkedList<>();
        if (start > end) {
            allTrees.add(null); // 这一句是必须的，否则创建不了结点
            return allTrees;
        }

        for (int i = start; i <= end; i++) {
            // 当前子树的左子树和右子树的所有可能的排列
            List<TreeNode> leftTrees = recursion(start, i - 1);
            List<TreeNode> rightTrees = recursion(i + 1, end);

            // 构建出当前子树所有可能的排列
            for (TreeNode left : leftTrees)
                for (TreeNode right : rightTrees) {
                    TreeNode node = new TreeNode(i);
                    node.left = left;
                    node.right = right;
                    allTrees.add(node);
                }
        }

        return allTrees;
    }
}
```

## 22日 旋转数组的最小数字 剑指offer11

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

**示例 1：**

```
输入：[3,4,5,1,2]
输出：1
```

**示例 2：**

```
输入：[2,2,2,0,1]
输出：0
```

**解法：**

```java
class Solution {
    public int minArray(int[] numbers) {
        int left = 0, right = numbers.length - 1;
        while (numbers[left] >= numbers[right]) {
            if (left == right - 1) {
                return numbers[right];
            }
            int mid = left + (right - left) / 2;
            if (numbers[left]==numbers[right]&&numbers[left]==numbers[mid]) {
                return inorderSearch(numbers, left, right);
            }
            if (numbers[mid] >= numbers[left])
                left = mid;
            else if (numbers[mid] <= numbers[right])
                right = mid; 
        }
        return numbers[left];
    }

    private int inorderSearch(int[] numbers, int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            if (numbers[i] < numbers[i - 1]) {
                return numbers[i];
            }
        }
        return numbers[left];
    }
}
```

## 23日 最小路径和64

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

**示例:**

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

**解法：**

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) return 0;
        int row = grid.length, col = grid[0].length;
        for (int i = 1; i < row; i++)
            grid[i][0] += grid[i - 1][0];
        for (int i = 1; i < col; i++)
            grid[0][i] += grid[0][i - 1];
        for (int i = 1; i < row; i++)
            for (int j = 1; j < col; j++) {
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        return grid[row - 1][col - 1];
    }
}
```

## 24日 除数博弈1025

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

选出任一 x，满足 0 < x < N 且 N % x == 0 。
用 N - x 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

**示例 1：**

```
输入：2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
```

**示例 2：**

```
输入：3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
```

**提示：**

- 1 <= N <= 1000

**解法：**

多列几项找规律可知，偶数先手必胜

```java
class Solution {
    public boolean divisorGame(int N) {
        if (N % 2 == 0) return true;
        return false;
    }
}
```

## 25日 分割数组的最大值410

给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。

**注意:**
数组长度 n 满足以下条件:

- 1 ≤ n ≤ 1000
- 1 ≤ m ≤ min(50, n)

**示例:**

```
输入:
nums = [7,2,5,10,8]
m = 2

输出:
18

解释:
一共有四种方法将nums分割为2个子数组。
其中最好的方式是将其分为[7,2,5] 和 [10,8]，
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小
```

**解法：**

```java
class Solution {
    public int splitArray(int[] nums, int m) {
        // 子数组和 可能的范围是 最大值 到 总和
        long left = 0, right = 0;
        int n = nums.length;
        for (int i : nums) {
            if (i > left) left = i;
            right += i;
        }
        // 在这个范围内找到能把数组分为n个子数组的最大值
        long ans = right;
        while (left <= right) {  // 二分
            long mid = left + (right - left) / 2;
            long sum = 0;   // 单个子数组的和
            long cnt = 1;   // 子数组的数量
            for (int i = 0; i < n; i++) {
                if (sum + nums[i] > mid) {
                    cnt++;
                    sum = nums[i];
                } else {
                    sum += nums[i];
                }
            }
            if (cnt <= m) { // 这一步保证找到最小的mid
                ans = Math.min(ans, mid);
                right = mid - 1;
            } else left = mid + 1;
        }
        return (int) ans;
    }
}
```

## 26日 矩阵中的最长递增路径

给定一个整数矩阵，找出最长递增路径的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。

**示例 1:**

```
输入: nums = 
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 
输出: 4 
解释: 最长递增路径为 [1, 2, 6, 9]。
```

**示例 2:**

```
输入: nums = 
[
  [3,4,5],
  [3,2,6],
  [2,2,1]
] 
输出: 4 
解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
```

**解法：**

记忆化dfs

```java
class Solution {
    Integer[][] memo;

    public int longestIncreasingPath(int[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) return 0;
        int res = 0;
        memo = new Integer[matrix.length][matrix[0].length];
        for (int i = 0; i < matrix.length; i++)
            for (int j = 0; j < matrix[0].length; j++) {
                res = Math.max(res, dfs(matrix, i, j, Long.MAX_VALUE));
            }
        return res;
    }

    int dfs(int[][] matrix, int x, int y, long last) {
        if (x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length || matrix[x][y] >= last) return 0;
        if (memo[x][y] != null) return memo[x][y];
        int step = dfs(matrix, x - 1, y, matrix[x][y]) + 1;
        step = Math.max(step, dfs(matrix, x + 1, y, matrix[x][y]) + 1);
        step = Math.max(step, dfs(matrix, x, y - 1, matrix[x][y]) + 1);
        step = Math.max(step, dfs(matrix, x, y + 1, matrix[x][y]) + 1);
        memo[x][y] = step;
        return step;
    }
}
```

## 27日 判断子序列392

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

**示例 1:**

```
s = "abc", t = "ahbgdc"
返回 true.
```

**示例 2:**

```
s = "axc", t = "ahbgdc"
返回 false.
```

**解法：**

这道题问的是子序列而不是子串，不问是kmp，是问 s 是否在 t 中按顺序出现。

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        if (s == null || s.length() == 0) return true;
        char[] chars = s.toCharArray();
        int index = -1;
        for (char c : chars) {
            index = t.indexOf(c, index + 1);
            if (index == -1) return false;
        }
        return true;
    }
}
```

## 28日 二叉树的最大深度104

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**

```
给定二叉树 [3,9,20,null,null,15,7]，

    3

   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。
```

**解法：**

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
```

## 29日 寻宝LCP13

我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。

迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 'S' 表示），和唯一的宝藏地点（用 'T' 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 'M' 表示），只有所有机关均被触发，才可以拿到宝藏。

要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 'O' 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。

迷宫中同样有一些墙壁（用 '#' 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 '.' 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。

我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。

**示例 1：**

```
输入： ["S#O", "M..", "M.T"]

输出：16

解释：最优路线为： S->O, cost = 4, 去搬石头 O->第二行的M, cost = 3, M机关触发 第二行的M->O, cost = 3, 我们需要继续回去 O 搬石头。 O->第三行的M, cost = 4, 此时所有机关均触发 第三行的M->T, cost = 2，去T点拿宝藏。 总步数为16。
```

![](img/72.gif)

**解法：**

bfs + dp

bfs算出起点到机关的距离（起点 - 石头 - 机关），机关到机关的距离（机关 - 石头 - 机关），机关到终点的距离（机关 - 终点）

dp是二维数组，$2^n$ 列，按位标记，比如5（101）就是去过第1个机关和第三个机关；n行，表示现在在第几个机关。n是机关数。

转移：![](img/73.png)

basecase:  站在第一个机关上时，路程是起点到第一个机关的距离。

```java
for (int i = 0; i < buttons.size(); i++)
	dp[1 << i][i] = dist[i][buttons.size()];
```

完整代码：

```java
class Solution {
    int[] dx = {1, -1, 0, 0};
    int[] dy = {0, 0, 1, -1};
    int row, col;

    public int minimalSteps(String[] maze) {
        this.row = maze.length;
        this.col = maze[0].length();
        List<int[]> buttons = new ArrayList<>();// 机关
        List<int[]> stones = new ArrayList<>(); // 石头
        int sx = -1, sy = -1;   // 起点
        int ex = -1, ey = -1;   // 终点
        // 初始化机关 石头 起点 终点
        for (int i = 0; i < row; i++)
            for (int j = 0; j < col; j++) {
                if (maze[i].charAt(j) == 'M')
                    buttons.add(new int[]{i, j});
                else if (maze[i].charAt(j) == 'O')
                    stones.add(new int[]{i, j});
                else if (maze[i].charAt(j) == 'S') {
                    sx = i;
                    sy = j;
                } else if (maze[i].charAt(j) == 'T') {
                    ex = i;
                    ey = j;
                }
            }
        // 各点到起点的距离
        int[][] startDist = bfs(sx, sy, maze);
        // 没有机关时的特殊处理
        if (buttons.size() == 0) return startDist[ex][ey];
        // 从某个机关到其他机关/起点/终点的距离
        int[][] dist = new int[buttons.size()][buttons.size() + 2];
        // 每个机关到个点的距离
        int[][][] dd = new int[buttons.size()][row][col];
        for (int i = 0; i < buttons.size(); i++) {
            int[][] d = bfs(buttons.get(i)[0], buttons.get(i)[1], maze);
            dd[i] = d;  // 初始化dd
            // 初始化每个机关到终点的距离
            dist[i][buttons.size() + 1] = d[ex][ey];
        }
        // 初始化dist数组
        for (int i = 0; i < buttons.size(); i++) {
            int tmp = -1;
            // 求从起点 拿到石头 到机关i的最短距离
            for (int j = 0; j < stones.size(); j++) {
                int stonex = stones.get(j)[0];
                int stoney = stones.get(j)[1];
                if (dd[i][stonex][stoney] != -1 && startDist[stonex][stoney] != -1 && (tmp == -1 || tmp > dd[i][stonex][stoney] + startDist[stonex][stoney])) 
                tmp = dd[i][stonex][stoney] + startDist[stonex][stoney];
            }
            dist[i][buttons.size()] = tmp;
            // 求从当前机关i 拿到石头k 到下一机关j的最短距离
            for (int j = 0; j < buttons.size(); j++) {
                int minDistance = -1;
                for (int k = 0; k < stones.size(); k++) {
                    int stonex = stones.get(k)[0];
                    int stoney = stones.get(k)[1];
                    if (dd[i][stonex][stoney] != -1 && dd[j][stonex][stoney] != -1 && (minDistance == -1 || minDistance > dd[i][stonex][stoney] + dd[j][stonex][stoney])) 
                    minDistance = dd[i][stonex][stoney] + dd[j][stonex][stoney];
                }
                dist[i][j] = minDistance;
                dist[j][i] = minDistance;
            }
        }

        // 机关无法到达起点或终点时 返回-1
        for (int i = 0; i < buttons.size(); i++) {
            if (dist[i][buttons.size()] == -1 || dist[i][buttons.size() + 1] == -1)
            return -1;
        }
        // dp数组 第一维是机关数个二级制位，位为1表到过2为没到过
        // 第二维表示当前处于哪个机关
        int[][] dp = new int[1 << buttons.size()][buttons.size()];
        for (int i = 0; i < dp.length; i++)
            Arrays.fill(dp[i], -1);
        // 从起点到第一个机关的距离
        for (int i = 0; i < buttons.size(); i++)
            dp[1 << i][i] = dist[i][buttons.size()];
        for (int mask = 1; mask < (1 << buttons.size()); mask++) {
            for (int i = 0; i < buttons.size(); i++) {
                if ((mask & (1 << i)) != 0) {   // 机关i到过
                    for (int j = 0; j < buttons.size(); j++) {
                        if ((mask & (1 << j)) == 0) { // 机关j没到过
                            int next = mask | (1 << j);
                            if (dp[next][j] == -1 || dp[next][j] > dp[mask][i] + dist[i][j]) 
                            dp[next][j] = dp[mask][i] + dist[i][j];
                        }
                    }
                }
            }
        }
        // 计算结果
        int res = -1;
        int finalMask = (1 << buttons.size()) - 1;
        for (int i = 0; i < buttons.size(); i++) {
            if (res == -1 || res > dp[finalMask][i] + dist[i][buttons.size() + 1])
            res = dp[finalMask][i] + dist[i][buttons.size() + 1];
        }
        return res;
    }

    // 以x, y为起点，到每一个点的距离
    private int[][] bfs(int x, int y, String[] maze) {
        int[][] res = new int[row][col];
        for (int i = 0; i < row; i++)
            Arrays.fill(res[i], -1);
        res[x][y] = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{x, y});
        while (!queue.isEmpty()) {
            int[] p = queue.poll();
            int curx = p[0], cury = p[1];
            for (int i = 0; i < 4; i++) {
                int nextx = curx + dx[i];
                int nexty = cury + dy[i];
                if (nextx < 0 || nextx >= row || nexty < 0 || nexty >= col || maze[nextx].charAt(nexty) == '#' || res[nextx][nexty] != -1) continue;
                res[nextx][nexty] = res[curx][cury] + 1;
                queue.offer(new int[]{nextx, nexty});
            }
        }
        return res;
    }
}
```

## 30日 整数拆分343

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
说明: 你可以假设 n 不小于 2 且不大于 58。
```

**解法：**

这个问题和剑指offer14是相同的，有dp和贪心两种解法

状态：i >= 4时：dp[i] = 长度为 i 的绳子的最大乘积；i < 4 时 dp[i] = i
转移：dp[i] = max(dp[i - x] * dp[x])
base case: i < 4 时 dp[i] = i。dp[0]舍弃。因为当n < 4时，剪过的乘积小于本身的长度，而题目要求至少剪一刀

```java
class Solution {
    public int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;
        for (int i = 4; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = Math.max(dp[i], dp[j] * dp[i - j]);
            }
        }
        return dp[n];
    }
}
```

贪心：

```java
class Solution {
    public int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        int num3 = n / 3;
        if (n - num3 * 3 == 1) num3--;
        int num2 = (n - num3 * 3) / 2;
        return (int)(Math.pow(3, num3) * Math.pow(2, num2));
    }
}
```

## 31日 魔术索引 面试题08.03

魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

**示例1:**

```
 输入：nums = [0, 2, 3, 4, 5]
 输出：0
 说明: 0下标的元素为0
```

**示例2:**

```
 输入：nums = [1, 1, 1]
 输出：1
```

**提示:**

- nums长度在[1, 1000000]之间


**解法：**

```java
class Solution {
    public int findMagicIndex(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == i) return i;
        }
        return -1;
    }
}
```

# 八月

## 1日 最小区间 632

你有 k 个升序排列的整数数组。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。

我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小。

**示例 1:**

```
输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]
输出: [20,24]
解释: 
列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。
列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。
列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。
```

**注意:**

- 给定的列表可能包含重复元素，所以在这里升序表示 >= 。
- 1 <= k <= 3500
- -105 <= 元素的值 <= 105

**解法：**

维护一个优先队列，存的是每一个列表的下标，按照该下标对应的元素排序。

这样每次出队的都是队列中的最小元素，用最大元素减最小元素，就可以算出区间大小。

把最小元素对应列表的下标后移，入队继续。

```java
class Solution {
    public int[] smallestRange(List<List<Integer>> nums) {
        int size = nums.size();
        int[] indexs = new int[size];
        PriorityQueue<Integer> pq = new PriorityQueue<>((idx1, idx2) -> 
        (nums.get(idx1).get(indexs[idx1]) - nums.get(idx2).get(indexs[idx2])));
        int maxn = Integer.MIN_VALUE;
        for (int i = 0; i < size; i++) {
            pq.offer(i);
            maxn = Math.max(maxn, nums.get(i).get(0));
        }
        int rangeLeft = 0, rangeRight = 0;
        int minRange = Integer.MAX_VALUE;
        while (true) {
            int minIdx = pq.poll();
            int curRange = maxn - nums.get(minIdx).get(indexs[minIdx]);
            if (curRange < minRange) {
                minRange = curRange;
                rangeLeft = nums.get(minIdx).get(indexs[minIdx]);
                rangeRight = maxn;
            }
            indexs[minIdx] += 1;
            if (indexs[minIdx] >= nums.get(minIdx).size()) break;
            pq.offer(minIdx);
            maxn = Math.max(maxn, nums.get(minIdx).get(indexs[minIdx]));
        }
        return new int[]{rangeLeft, rangeRight};
    }
}
```

## 2日 二叉树展开为链表114

给定一个二叉树，原地将它展开为一个单链表。

例如，给定二叉树

```
    1
   / \
  2   5
 / \   \
3   4   6
```

将其展开为：

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

**解法：**

可以看出展开后是按前序排列的，可以在前序的基础上加一些修改操作。

先让前一个结点的右侧结点等于当前结点，而前一个结点的右侧结点已被保存在栈中。

最后别忘了让当前结点的左侧结点为空。

```java
class Solution {
    public void flatten(TreeNode root) {
        if (root == null) return;
        TreeNode pre = new TreeNode();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node = root;
        while (true) {
            while (node != null) {
                pre.right = node;
                stack.push(node.right);	// 前序
                pre = node;
                node = node.left;	// 前序
                pre.left = null;
            }
            if (stack.isEmpty()) break;
            node = stack.pop();
        }
    }
}
```

真正能原地的算法，当前结点如果有左子树，则把当前结点的右子树放到，左子树的最右边，再把当前结点的左子树变为右子树。

```java
class Solution {
    public void flatten(TreeNode root) {
        TreeNode cur = root;
        while (cur != null) {
            if (cur.left != null) {
                // 如果有左子树，当前结点的next应该是左子树的根节点
                TreeNode next = cur.left;
                TreeNode leftTail = next;
                while (leftTail.right != null) {
                    leftTail = leftTail.right;
                }
                // 当前结点的右子树放到左子树的最右边
                leftTail.right = cur.right;
                // 当前结点的左子树变为右子树
                cur.left = null;
                cur.right = next;
            }
            cur = cur.right;
        }
    }
}
```

## 3日 字符串相加415

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

**提示：**

- num1 和num2 的长度都小于 5100
- num1 和num2 都只包含数字 0-9
- num1 和num2 都不包含任何前导零
- 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式

**解法：**

```java
class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder sb = new StringBuilder();
        int jinwei = 0;
        int idx1 = num1.length(), idx2 = num2.length();
        while (idx1 > 0 && idx2 > 0) {
            idx1--; idx2--;
            int cur1 = num1.charAt(idx1) - '0';
            int cur2 = num2.charAt(idx2) - '0';
            int sum = cur1 + cur2 + jinwei;
            sb.append(sum % 10);
            jinwei = sum / 10;
        }
        while (idx1 > 0) {
            idx1--;
            int cur1 = num1.charAt(idx1) - '0';
            int sum = cur1 + jinwei;
            sb.append(sum % 10);
            jinwei = sum / 10;
        }
        while (idx2 > 0) {
            idx2--;
            int cur2 = num2.charAt(idx2) - '0';
            int sum = cur2 + jinwei;
            sb.append(sum % 10);
            jinwei = sum / 10;
        }
        if (jinwei != 0) sb.append(jinwei);
        return sb.reverse().toString();
    }
}
```

## 4日 课程表207

你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

**示例 1:**

```
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
```

**示例 2:**

```
输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

**提示：**

- 输入的先决条件是由 **边列表** 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。
- 你可以假定输入的先决条件中没有重复的边。
- 1 <= numCourses <= 10^5

**解法：**

这个问题的本质是在问有向图是否有拓扑排序，如果有环则不能拓扑排序。[官方题解](https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/)

基于dfs

```java
class Solution {
    List<List<Integer>> edges;
    Boolean[] visited;  // null未搜索false搜索中true搜索过
    boolean valid = true;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<>();
        for (int i = 0; i < numCourses; i++)
            edges.add(new ArrayList<>());
        visited = new Boolean[numCourses];
        for (int[] p : prerequisites) 
            edges.get(p[1]).add(p[0]);
        for (int i = 0; i < numCourses; i++) {
            if (visited[i] == null) dfs(i);
        }
        return valid;
    }

    private void dfs(int course) {
        visited[course] = false;
        for (int v : edges.get(course)) {
            if (visited[v] == null) {
                dfs(v);
                if(!valid) return;
            } else if (visited[v] == false) {
                valid = false;
                return;
            }
        }
        visited[course] = true;
        // 如果需要拓扑排序结果，就在这里进栈
    }
}
```

bfs

```java
class Solution {
    List<List<Integer>> edges;  // 邻接表
    int[] indegree; // 入度

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<>();
        indegree = new int[numCourses];
        for (int i = 0; i < numCourses; i++)
            edges.add(new ArrayList<>());
        for (int[] p : prerequisites) {
            edges.get(p[1]).add(p[0]);
            indegree[p[0]]++;
        }
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++)
            if (indegree[i] == 0) queue.offer(i);
        int visited = 0;
        while (!queue.isEmpty()) {
            ++visited;
            int u = queue.poll();
            for (int v : edges.get(u)) {
                indegree[v]--;
                if (indegree[v] == 0) queue.offer(v);
            }
        }
        return visited == numCourses;
    }
}
```

## 5日 打家劫舍III 337

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

**示例 1:**

```
输入: [3,2,3,null,3,null,1]
     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```

**示例 2:**

```
输入: [3,4,5,1,3,null,1]
     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```

**解法：**

```java
class Solution {
    Map<TreeNode, Integer> map = new HashMap<>();
    public int rob(TreeNode root) {
        if (root == null) return 0;
        if (map.containsKey(root)) return map.get(root);
        int do_it = root.val + 
            ((root.left != null) ? 
                rob(root.left.left) + rob(root.left.right) : 0)
            + ((root.right != null) ?
                rob(root.right.left) + rob(root.right.right) : 0);
        int not_do = rob(root.left) + rob(root.right);
        int res = Math.max(do_it, not_do);
        map.put(root, res);
        return res;
    }
}
```

## 6日 回文对336

给定一组**唯一**的单词， 找出所有**不同**的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。

**示例 1:**

```
输入: ["abcd","dcba","lls","s","sssll"]
输出: [[0,1],[1,0],[3,2],[2,4]] 
解释: 可拼接成的回文串为 ["dcbaabcd","abcddcba","slls","llssssll"]
```

**示例 2:**

```
输入: ["bat","tab","cat"]
输出: [[0,1],[1,0]] 
解释: 可拼接成的回文串为 ["battab","tabbat"]
```

**解法：**

构建字典树，对每一个字符串s1查找字典树找另一个字符串s2，s1连接s2分三种情况：

- s1和s2一样长，直接查字典树即可找到s2。
- s1比s2长，判断s1右侧是否为回文，s2是否为s1左侧的倒序。
- s1比s2短，判断s2左侧是否为回文，s1是否为s2右侧的倒序。

第一个if是前两种情况，第二个if是第三种情况，注意边界条件。

```java
class Node {
    Node[] nexts = new Node[26];
    int whichEnd = -1;
}

class Solution {
    Node root = new Node();

    public List<List<Integer>> palindromePairs(String[] words) {
        for (int i = 0; i < words.length; i++)
            addWord(words[i], i);
        List<List<Integer>> res = new LinkedList<>();
        for (int i = 0; i < words.length; i++) {
            int len = words[i].length();
            for (int j = 0; j <= len; j++) {
                if (isParlindrome(words[i], j, len - 1)) {
                    int index = findWord(words[i], 0, j - 1);
                    if (index != -1 && index != i) 
                        res.add(Arrays.asList(i, index));
                }
                if (j != 0 && isParlindrome(words[i], 0, j - 1)) {
                    int index = findWord(words[i], j, len - 1);
                    if (index != -1 && index != i)
                        res.add(Arrays.asList(index, i));
                }
            }
        }
        return res;
    }

    private void addWord(String s, int index) {
        Node node = root;
        for (int i = 0; i < s.length(); i++) {
            int idx = s.charAt(i) - 'a';
            if (node.nexts[idx] == null)
                node.nexts[idx] = new Node();
            node = node.nexts[idx];
        }
        node.whichEnd = index;
    }

    private boolean isParlindrome(String s, int start, int end) {
        while (start < end) {
            if (s.charAt(start) != s.charAt(end)) return false;
            start++;
            end--;
        }
        return true;
    }

    private int findWord(String s, int start, int end) {
        Node node = root;
        for (int i = end; i >= start; i--) {
            int idx = s.charAt(i) - 'a';
            if (node.nexts[idx] == null) return -1;
            node = node.nexts[idx];
        }
        return node.whichEnd;
    }
}
```

## 7日 相同的树100

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1:**

```
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

**示例 2:**

```
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```

**解法：**

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null) return false;
        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

## 8日 恢复二叉搜索树99

二叉搜索树中的两个节点被错误地交换。

请在不改变其结构的情况下，恢复这棵树。

**示例 1:**

```
输入: [1,3,null,null,2]

   1
  /
 3
  \
   2

输出: [3,1,null,null,2]

   3
  /
 1
  \
   2
```

**示例 2:**

```
输入: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

输出: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3
```

**进阶:**

- 使用 O(n) 空间复杂度的解法很容易实现。
- 你能想出一个只使用常数空间的解决方案吗？

**解法：**

相同形状的相同元素的二叉搜索树只有一种，可以先求出中序遍历，然后把中序遍历纠正，再填回BST中

有两个元素顺序不对的数组排序最笨的方法就是冒泡排序正反各来两趟，更好的方法是求出两个下标，再交换。因为数组是升序，那么大的无序肯定在前面，小的无序在后面；大的是无序对的前一个，小的是无序对的后一个。

比如：3 2 1； 3 2所以大无序是3，2 1所以小无序是1； 3 1互换后，有序。

又如：-33 321 55 71 146 231 -13 399；321 55所以321；-13 399所以-13；321 -13换，懂？

```java
class Solution {
    List<Integer> list = new ArrayList<>();

    public void recoverTree(TreeNode root) {
        inorder(root);
        findAndSwap();
        int index = 0;
        Deque<TreeNode> stack = new LinkedList();
        while (true) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            if (stack.isEmpty()) break;
            root = stack.pop();
            root.val = list.get(index++);
            root = root.right;
        }
    }

    private void inorder(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList();
        while (true) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            if (stack.isEmpty()) break;
            root = stack.pop();
            list.add(root.val);
            root = root.right;
        }
    }

    private void findAndSwap() {
        int x = -1, y = -1;
        for (int i = 0; i < list.size() - 1; i++) {
            if (list.get(i) > list.get(i + 1)) {
                y = i + 1;
                if (x == -1) x = i;
                else break;
            }
        }
        int tmp = list.get(x);
        list.set(x, list.get(y));
        list.set(y, tmp);
    }
}
```

 空间复杂度为O（n）n为元素个数，因为用了list存了所有元素。

也可以不存到list，直接在中序遍历的过程中使用相同的方法找出x，y，再交换。

```java
class Solution {
    public void recoverTree(TreeNode root) {
        TreeNode pre = null, x = null, y = null;
        Deque<TreeNode> stack = new LinkedList<>();
        while (true) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            if (stack.isEmpty()) break;
            root = stack.pop();
            if (pre != null && pre.val > root.val) {
                y = root;
                if (x == null) x = pre;
                else break;
            }
            pre = root;
            root = root.right;
        }

        swap(x, y);
    }

    private void swap(TreeNode x, TreeNode y) {
        int tmp = x.val;
        x.val = y.val;
        y.val = tmp;
    }
}
```

这样空间复杂度降低到了O(树高) 因为有栈，时间复杂度仍然是O(n)

这样空间复杂度的瓶颈就是中序遍历了，想要空间复杂度降到O（1）则需要Morris 中序遍历法。

## 9日 复原IP地址93

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 '.' 分隔。

**示例:**

```
输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
```

**解法：**

细节：非0数字不能以0开头，ip地址不能出现类似 01，001 这样的数字。

如果输入字符串长度大于12，直接返回空数组。

解法一，三层循环，i，j，k 分别代表三个点的插入位置

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> res = new LinkedList<>();
        if (s.length() > 12) return res;
        for (int i = 1; i <= 3; i++)
            for (int j = 1; j <= 3; j++)
                for (int k = 1; k <= 3; k++) {
                    if (i + j + k >= s.length()) continue;
                    String s1 = s.substring(0, i);
                    if (i != 1 && s1.charAt(0) == '0') continue;
                    String s2 = s.substring(i, i + j);
                    if (j != 1 && s2.charAt(0) == '0') continue;
                    String s3 = s.substring(i + j, i + j + k);
                    if (k != 1 && s3.charAt(0) == '0') continue;
                    String s4 = s.substring(i + j + k);
                    if (s4.length() > 1 && s4.charAt(0) == '0') continue;
                    int n1 = Integer.parseInt(s1);
                    int n2 = Integer.parseInt(s2);
                    int n3 = Integer.parseInt(s3);
                    long n4 = Long.parseLong(s4);
                    if (n1 < 256 && n2 < 256 && n3 < 256 && n4 < 256) {
                        StringBuilder sb = new StringBuilder();
                        sb.append(n1).append('.');
                        sb.append(n2).append('.');
                        sb.append(n3).append('.');
                        sb.append(n4);
                        res.add(sb.toString());
                    }
                }
        return res;
    }
}
```

解法二，回溯

```java
class Solution {
    List<String> res = new LinkedList<>();
    int[] segs = new int[4];
    String s;

    public List<String> restoreIpAddresses(String s) {
        if (s.length() > 12) return res;
        this.s = s;
        backTrace(0, 0);
        return res;
    }

    // 第几个数字，字符串中的下标
    private void backTrace(int segNum, int index) {
        if (segNum == 4 && index == s.length()) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 3; i++) 
                sb.append(segs[i]).append('.');
            sb.append(segs[3]);
            res.add(sb.toString());
            return;
        }
        if (segNum == 4) return;
        if (segNum != 4 && index == s.length()) return;
        if (s.charAt(index) == '0') {
            segs[segNum] = 0;
            backTrace(segNum + 1, index + 1);
        }
        int addr = 0;
        for (int i = index; i < s.length(); i++) {
            addr = (s.charAt(i) - '0') + addr * 10;
            if (addr > 0 && addr <= 255) {
                segs[segNum] = addr;
                backTrace(segNum + 1, i + 1);
            } else {
                break;
            }
        }
    }
}
```

## 10日 计数二进制子串696

给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**

```
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
请注意，一些重复出现的子串要计算它们出现的次数。
另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
```

**示例 2 :**

```
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
```

**注意：**

- s.length 在1到50,000之间。
- s 只包含“0”或“1”字符。

**解法：**

0是连续的 1也是连续的，所以不是dp或者前缀和。子串之间可以重叠。

这里使用preCount记录之前连续的数量，curCount记录当前连续的数量。preCount和curCount的最小值就是当前重复子串的出现次数。

```java
class Solution {
    public int countBinarySubstrings(String s) {
        if (s.length() == 0) return 0;
        char a = s.charAt(0);
        int curCount = 0, preCount = 0, sum = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == a) curCount++;
            if (s.charAt(i) != a) {
                if (preCount != 0)
                    sum += Math.min(curCount, preCount);
                a = s.charAt(i);
                preCount = curCount;
                curCount = 1;
            }
        }
        if (preCount != 0) sum += Math.min(curCount, preCount);
        return sum;
    }
}
```

## 11日 被围绕的区域130

给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。

找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。

**示例:**

```
X X X X
X O O X
X X O X
X O X X
```


运行你的函数后，矩阵变为：

```
X X X X
X X X X
X X X X
X O X X
```

**解释:**

被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。

**解法：**

对矩阵边上的每一个 'O' 进行dfs

```java
class Solution {
    char[][] board;

    public void solve(char[][] board) {
        this.board = board;
        if (board.length == 0 || board[0].length == 0) return;
        int row = board.length, col = board[0].length;
        for (int i = 0; i < row; i++)
            if (board[i][0] == 'O') dfs(i, 0);
        for (int i = 0; i < row; i++)
            if (board[i][col - 1] == 'O') dfs (i, col - 1);
        for (int i = 0; i < col; i++)
            if (board[0][i] == 'O') dfs(0, i);
        for (int i = 0; i < col; i++)
            if (board[row - 1][i] == 'O') dfs(row - 1, i); 
        for (int i = 0; i < row; i++)
            for (int j = 0; j < col; j++) {
                if (board[i][j] != 'N') board[i][j] = 'X';
                else board[i][j] = 'O';
            }
    }

    private void dfs(int r, int c) {
        if (r < 0 || r >= board.length || c < 0 || c >= board[0].length || board[r][c] != 'O') return;
        board[r][c] = 'N';
        dfs(r + 1, c);
        dfs(r - 1, c);
        dfs(r, c + 1);
        dfs(r, c - 1);
    }
}
```

## 12日 克隆图133

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。

图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。

```
class Node {
    public int val;
    public List<Node> neighbors;
}
```

**解法：**

使用Map，key是原结点，value是克隆后的结点。

```java
class Solution {
    Map<Node, Node> map = new HashMap<>();

    public Node cloneGraph(Node node) {
        if (node == null) return null;
        dfs(node);
        for (Node n : map.keySet()) {
            for (Node nei : n.neighbors) {
                map.get(n).neighbors.add(map.get(nei));
            }
        }
        return map.get(node);
    }

    private void dfs(Node node) {
        if (map.containsKey(node)) return;
        map.put(node, new Node(node.val));
        for (Node n : node.neighbors) {
            dfs(n);
        }
    }
}
```

## 13日 字符串相乘 43

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

**示例 1:**

```
输入: num1 = "2", num2 = "3"
输出: "6"
```


**示例 2:**

```
输入: num1 = "123", num2 = "456"
输出: "56088"
```


**说明：**

- num1 和 num2 的长度小于110。
- num1 和 num2 只包含数字 0-9。
- num1 和 num2 均不以零开头，除非是数字 0 本身。
- 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。

**解法：**

模拟乘法竖式

```java
class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";
        String ans = "0";
        for (int i = num1.length() - 1; i >= 0 ; i--) {
            int jinwei = 0, number = num1.charAt(i) - '0';
            StringBuilder sb = new StringBuilder();
            for (int j = num1.length() - 1; j > i; j--)
                sb.append('0');
            for (int j = num2.length() - 1; j >= 0 ; j--) {
                int mul = num2.charAt(j) - '0';
                int res = mul * number + jinwei;
                sb.append(res % 10);
                jinwei = res / 10;
            }
            if (jinwei != 0) sb.append(jinwei);

            ans = addSum(ans, sb.toString());
        }
        StringBuilder tmp = new StringBuilder(ans);
        return tmp.reverse().toString();
    }

    private String addSum(String x, String y) {
        StringBuilder ans = new StringBuilder();
        int jinwei = 0, xLen = x.length(), yLen = y.length();
        int i = 0, j = 0;
        while (i < xLen || j < yLen || jinwei != 0) {
            int a = (i < xLen) ? x.charAt(i) - '0' : 0;
            int b = (j < yLen) ? y.charAt(i) - '0' : 0;
            int sum = a + b + jinwei;
            ans.append(sum % 10);
            jinwei = sum / 10;
            i++;
            j++;
        }
        return ans.toString();
    }
}
```

## 14日 有效的括号 20

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**

```
输入: "()"
输出: true
```


**示例 2:**

```
输入: "(]"
输出: false
```

**解法：**

```java
class Solution {
    public boolean isValid(String s) {
        Map<Character, Character> map = new HashMap<>();
        map.put('{', '}');
        map.put('[', ']');
        map.put('(', ')');

        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (map.containsKey(c)) stack.add(c);   // 左括号入栈
            else if (!stack.isEmpty() && map.get(stack.peek()) == c)
                stack.pop();// 和栈顶左括号匹配
            else return false;  // 既不是左括号，又不和栈顶酦醅
        }
        return stack.isEmpty();
    }
}
```

## 15日 移除盒子546

给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。
你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k*k 个积分。
当你将所有盒子都去掉之后，求你能获得的最大积分和。

**示例：**

```
输入：boxes = [1,3,2,2,2,3,4,3,1]
输出：23
解释：
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 分) 
----> [1, 3, 3, 3, 1] (1*1=1 分) 
----> [1, 1] (3*3=9 分) 
----> [] (2*2=4 分)
```

**提示：**

- 1 <= boxes.length <= 100
- 1 <= boxes[i] <= 100

**解法：**

```java
class Solution {
    int[][][] dp;
    int[] boxes;

    public int removeBoxes(int[] boxes) {
        int n = boxes.length;
        dp = new int[n][n][n];
        this.boxes = boxes;
        return removingbox(0, n - 1, 0);
    }
    
    private int removingbox(int i, int j, int k) {
        if (i > j) return 0;
        if (dp[i][j][k] > 0) return dp[i][j][k];
        while (i < j && boxes[i + 1] == boxes[i]) {
            i ++;
            k ++;
        }
        int res = (k + 1) * (k + 1) + removingbox(i + 1, j, 0);
        for (int m = i + 1; m <= j; m ++) {
            if (boxes[m] == boxes[i]) {
                res = Math.max(res, removingbox(i + 1, m - 1, 0) + removingbox(m, j, 1 + k));
            }
        }
        return dp[i][j][k] = res;
    }
}
```

## 16日 图像渲染733

有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。

给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。

为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。

最后返回经过上色渲染后的图像。

**示例 1:**

```
输入: 
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析: 
在图像的正中间，(坐标(sr,sc)=(1,1)),
在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，
因为它不是在上下左右四个方向上与初始点相连的像素点。
```

**注意:**

- image 和 image[0] 的长度在范围 [1, 50] 内。
- 给出的初始点将满足 0 <= sr < image.length 和 0 <= sc < image[0].length。
- image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int oldColor = image[sr][sc];
        if (oldColor == newColor) return image;
        int height = image.length;
        int width = image[0].length;
        Queue<Integer> indexs = new LinkedList<>();
        indexs.offer(sr * width + sc);
        while (!indexs.isEmpty()) {
            int row = indexs.peek() / width;
            int col = indexs.peek() % width;
            indexs.poll();
            if (image[row][col] == oldColor) image[row][col] = newColor;
            if (row != 0 && image[row - 1][col] == oldColor)
                indexs.offer((row - 1) * width + col);
            if (col != 0 && image[row][col - 1] == oldColor)
                indexs.offer(row * width + col - 1);
            if (row + 1 != height && image[row + 1][col] == oldColor)
                indexs.offer((row + 1) * width + col);
            if (col + 1 != width && image[row][col + 1] == oldColor)
                indexs.offer(row * width + col + 1);
        }
        return image;
    }
}
```

## 17日 平衡二叉树110

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

- 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。


**示例 1:**

```
给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。
```

**示例 2:**

```
给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。
```

**解法：**

```java
class TreeInfo {
    int height;
    boolean balanced;

    TreeInfo(int height, boolean balanced) {
        this.height = height;
        this.balanced = balanced;
    }
}

class Solution {
    private TreeInfo recursion(TreeNode node) {
        if (node == null) return new TreeInfo(0, true);

        TreeInfo left = recursion(node.left);
        if (!left.balanced) return new TreeInfo(0, false);

        TreeInfo right = recursion(node.right);
        if (!right.balanced) return new TreeInfo(0, false);

        if (Math.abs(left.height - right.height) < 2)
            return new TreeInfo(Math.max(left.height,right.height) + 1, true);
        return new TreeInfo(0, false);
    }

    public boolean isBalanced(TreeNode root) {
        return recursion(root).balanced;
    }
}
```

## 18日 有序链表转换二叉树 109

给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

**示例:**

```
给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \

   -3   9
   /   /
 -10  5
```

**解法：**

数组转换二叉树

```java
class Solution {
    List<Integer> list = new ArrayList<>();

    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) return null;
        while (head != null) {
            list.add(head.val);
            head = head.next;
        }
        return recursion(0, list.size() - 1);
    }

    private TreeNode recursion(int left, int right) {
        if (left > right) return null;
        if (left == right) return new TreeNode(list.get(left));
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(list.get(mid));
        node.left = recursion(left, mid - 1);
        node.right = recursion(mid + 1, right);
        return node;
    }
}
```

利用链表的特性，直接在链表里找结点

```java
class Solution {

    public TreeNode sortedListToBST(ListNode head) {
        return recursion(head, null);
    }

    private TreeNode recursion(ListNode left, ListNode right) {
        if (left == right) return null;
        ListNode mid = getMedian(left, right);
        TreeNode node = new TreeNode(mid.val);
        node.left = recursion(left, mid);
        node.right = recursion(mid.next, right);
        return node;
    }

    private ListNode getMedian(ListNode left, ListNode right) {
        ListNode fast = left;
        ListNode slow = left;
        while (fast != right && fast.next != right) {
            fast = fast.next;
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

更好的方法，中序遍历优化

```java
class Solution {
    ListNode head;

    public TreeNode sortedListToBST(ListNode head) {
        this.head = head;
        ListNode node = head;
        int len = 0;
        while (node != null) {
            node = node.next;
            len++;
        }
        return recursion(0, len - 1);
    }

    private TreeNode recursion(int left, int right) {
        if (left > right) return null;
        int mid = (left + right) / 2;
        TreeNode node = new TreeNode();
        // 左子树使用 前mid - 1个 listNode
        node.left = recursion(left, mid - 1);
        // 当前结点使用 第mid个 listNode
        node.val = this.head.val;
        this.head = this.head.next;
        // 左子树使用 后mid + 1个 listNode
        node.right = recursion(mid + 1, right);
        return node;
    }
}
```

## 19日 回文子串 647

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

**示例 1：**

```
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```


**示例 2：**

```
输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

**提示：**

- 输入的字符串长度不会超过 1000 。


**解法：**

首先可以想到dp，要注意三角型的dp要由窄到宽，比如上三角就从下往上dp，下三角就从上往下dp

```java
class Solution {
    public int countSubstrings(String s) {
        boolean[][] dp = new boolean[s.length()][s.length()];
        for (int i = 0; i < s.length(); i++) dp[i][i] = true;
        int res = s.length();
        for (int i = s.length() - 2; i >= 0; i--) {
            for (int j = i + 1; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (i + 1 == j) { 
                        dp[i][j] = true;
                        res++;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                        if (dp[i][j]) res++;
                    }
                }
            }
        }
        return res;
    }
}
```

中心拓展法：

每个字符和每两个字符中间的位置就可以看作回文中心，向两边拓展，直到不是回文

```java
class Solution {
    public int countSubstrings(String s) {
        int sLen = s.length(), res = 0;
        for (int i = 0; i < sLen * 2 - 1; i++) {
            int left = i / 2, right = i / 2 + i % 2;
            while (left >= 0 && right < sLen && s.charAt(left) == s.charAt(right)) {
                left--;
                right++;
                res++;
            }
        }
        return res;
    }
}
```

## 20日 扫雷游戏 529

让我们一起来玩扫雷游戏！

给定一个代表游戏板的二维字符矩阵。 'M' 代表一个未挖出的地雷，'E' 代表一个未挖出的空方块，'B' 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（'1' 到 '8'）表示有多少地雷与这块已挖出的方块相邻，'X' 则表示一个已挖出的地雷。

现在给出在所有未挖出的方块中（'M'或者'E'）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：

如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X'。
如果一个没有相邻地雷的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的未挖出方块都应该被递归地揭露。
如果一个至少与一个地雷相邻的空方块（'E'）被挖出，修改它为数字（'1'到'8'），表示相邻地雷的数量。
如果在此次点击中，若无更多方块可被揭露，则返回面板。


**示例 1：**

```
输入: 
[['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'M', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E']]
Click : [3,0]

输出: 
[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]
```

**示例 2：**

```
输入: 
[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Click : [1,2]

输出: 
[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'X', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]
```

**注意：**

- 输入矩阵的宽和高的范围为 [1,50]。
- 点击的位置只能是未被挖出的方块 ('M' 或者 'E')，这也意味着面板至少包含一个可点击的方块。
- 输入面板不会是游戏结束的状态（即有地雷已被挖出）。
- 简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。

**解法：**

```java
class Solution {
    char[][] board;
    int row;
    int col;

    public char[][] updateBoard(char[][] board, int[] click) {
        this.board = board;
        this.row = board.length;
        this.col = board[0].length;
        // 规则1
        if (board[click[0]][click[1]] == 'M') {
            board[click[0]][click[1]] = 'X';
            return this.board;
        }
        dfs(click[0], click[1]);
        return this.board;
    }

    private void dfs(int r, int c) {
        if (r < 0 || r >= row || c < 0 || c >= col || board[r][c] != 'E')
            return;
        int cnt = count(r, c);
        if (cnt > 0) { 
            // 规则3
            board[r][c] = (char)(cnt + '0');
        } else {
            // 规则2
            board[r][c] = 'B';
            dfs(r - 1, c);
            dfs(r + 1, c);
            dfs(r, c - 1);
            dfs(r, c + 1);
            dfs(r - 1, c + 1);
            dfs(r + 1, c - 1);
            dfs(r - 1, c - 1);
            dfs(r + 1, c + 1);
        }
        
    }

    private int count(int r, int c) {
        int res = 0;
        for (int i = r - 1; i <= r + 1; i++) {
            for (int j = c - 1; j <= c + 1; j++) {
                if (isInBounds(i, j) && board[i][j] == 'M')
                    res++;            
            }
        }
        return res;
    }

    private boolean isInBounds(int r, int c) {
        if (r < 0 || r >= row || c < 0 || c >= col) 
            return false;
        return true;
    }
}
```

## 21日 二叉树的最小深度 111

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

**示例:**

```
给定二叉树 [3,9,20,null,null,15,7],

    3

   / \
  9  20
    /  \
   15   7
返回它的最小深度  2.
```

**解法：**

```java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        if (root.left == null && root.right == null) {
            return 1;
        }

        int min_depth = Integer.MAX_VALUE;
        if (root.left != null) {
            min_depth = Math.min(minDepth(root.left), min_depth);
        }
        if (root.right != null) {
            min_depth = Math.min(minDepth(root.right), min_depth);
        }

        return min_depth + 1;
    }
}
```

## 22日 24点游戏 679

你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。

**示例 1:**

```
输入: [4, 1, 8, 7]
输出: True
解释: (8-4) * (7-1) = 24
```

**示例 2:**

```
输入: [1, 2, 1, 2]
输出: False
```

**注意:**

- 除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。
- 每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。
- 你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。

**解法：**

每次都拿出两个数字尝试加减乘除

```java
class Solution {
    static final int TARGET = 24;
    static final double EPSILON = 1e-6;
    static final int ADD = 1, SUB = 2, MUL = 3, DIV = 4;

    public boolean judgePoint24(int[] nums) {
        List<Double> list = new ArrayList<>();
        for (int i = 0; i < 4; i++) list.add((double)nums[i]);
        return solve(list);
    }

    private boolean solve(List<Double> list) {
        if (list.size() == 0) return false;
        if (list.size() == 1) return Math.abs(list.get(0) - 24) < EPSILON;
        for (int i = 0; i < list.size(); i++) {
            for (int j = 0; j < list.size(); j++) {
                if (i != j) {
                    List<Double> tmp = new ArrayList<>();
                    for (int k = 0; k < list.size(); k++) {
                        if (k != i && k != j) tmp.add(list.get(k));
                    }
                    for (int k = 1; k <= 4; k++) {
                        if (k == ADD) 
                            tmp.add(list.get(i) + list.get(j));
                        else if (k == SUB) 
                            tmp.add(list.get(i) - list.get(j));
                        else if (k == MUL) 
                            tmp.add(list.get(i) * list.get(j));
                        else if (k == DIV) {
                            if (Math.abs(list.get(j)) < EPSILON) continue;
                            tmp.add(list.get(i) / list.get(j));
                        }
                        if (solve(tmp)) return true;
                        else tmp.remove(tmp.size() - 1);
                    }
                }
            }
        }
        return false;
    }
}
```

## 23日 数字范围按位与 201

给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

**示例 1:** 

```
输入: [5,7]
输出: 4
```

**示例 2:**

```
输入: [0,1]
输出: 0
```

**解法：**

直接对每一个数字按位与会超时。

这个问题可以简化为对m和n求最长公共前缀，先对m和n不断右移，并记下右移次数shift，当m和n相等时，再左移shift次，就可以求出所有数字的按位与。

```java
class Solution {
    public int rangeBitwiseAnd(int m, int n) {
        int res = n, shift = 0;
        while (m < n) {
            m = m >>> 1;
            n = n >>> 1;
            shift++;
        }
        return m << shift;
    }
}
```

## 24日 重复的子字符串 459

给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

**示例 1:**

```
输入: "abab"
输出: True
解释: 可由子字符串 "ab" 重复两次构成。
```

**示例 2:**

```
输入: "aba"
输出: False
```

**示例 3:**

```
输入: "abcabcabcabc"
输出: True
解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)
```

**解法：**

把整个字符串重复两次，再舍弃第一个字符找字符串s，如果找到的s的起始下标不是s的长度，则返回真

比如：输入"accacc" 重复两次就是"accaccaccacc"，跳过首个字符找"accacc"得到的起始下标是3而不是6，所以返回true

又如：输入"abc" 重复两次是"abcabc"，跳过首个字母找"abc"得到的起始下标是3，"abc"长度也是3，所以返回false。

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        return (s + s).indexOf(s, 1) != s.length();
    }
}
```

## 25日 递增子序列 491

给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

**示例:**

```
输入: [4, 6, 7, 7]
输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]
```

**说明:**

- 给定数组的长度不会超过15。
- 数组中的整数范围是 [-100,100]。
- 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。

**解法：**

使用回溯，但有些不同，首先结束的条件不能像组合一样`if (track.size() >= 2) {res.add(new LinkedList(track)); return;}`，这样输出的都是长度为2的；应该运算到最后一个数字，即`cur == nums.length`时，才能添加结果。

回溯的过程：

1. 如果当前数字大于上一个（满足递增），则可以把这个数字加入子序列
2. 也可以选择不把当前数字加入子序列，但要考虑去重，所以要加一个`nums[cur] != last`的判断，避免出现两个`[4, 7]`之类的情况。

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        LinkedList<Integer> track = new LinkedList<>();
        backTrace(nums, 0, -101, track);
        return res;
    }

    private void backTrace(int[] nums, int cur, int last, LinkedList<Integer> track) {
        if (cur == nums.length) {
            if (track.size() >= 2) res.add(new LinkedList(track));
            return;
        }
        if (nums[cur] >= last) {
            track.add(nums[cur]);
            backTrace(nums, cur + 1, nums[cur], track);
            track.removeLast();
        }
        if (nums[cur] != last) {
            backTrace(nums, cur + 1, last, track);
        }
    }
}
```

## 26日 电话号码的字母组合 17

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

<img src="img/74.png" style="zoom:33%;" />

**示例:**

```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

**说明:**
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。

**解法：**

使用回溯

```java
class Solution {
    List<String> res = new LinkedList<>();
    char [][] nums = {{}, {}, {'a', 'b', 'c'}, 
                    {'d', 'e', 'f'}, {'g', 'h', 'i'},
                    {'j', 'k', 'l'}, {'m', 'n', 'o'},
                    {'p', 'q', 'r', 's'}, {'t', 'u', 'v'},
                    {'w', 'x', 'y', 'z'}};

    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) return res;
        String s = "";
        backTrace(s, digits);
        return res;
    }

    private void backTrace(String s, String digits) {
        if (s.length() == digits.length()) {
            res.add(s);
            return;
        }
        int idx = digits.charAt(s.length()) - '0';
        for (int i = 0; i < nums[idx].length; i++) {
            s = s + nums[idx][i];
            backTrace(s, digits);
            s = s.substring(0, s.length() - 1);
        }
    }
}
```

## 27日 重新安排行程 332

给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。

**说明:**

- 如果存在多种有效的行程，你可以按字符自然排序返回最小的行程组合。例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前
- 所有的机场都用三个大写字母表示（机场代码）。
- 假定所有机票至少存在一种合理的行程。

**示例 1:**

```
输入: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
输出: ["JFK", "MUC", "LHR", "SFO", "SJC"]
```


**示例 2:**

```
输入: [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出: ["JFK","ATL","JFK","SFO","ATL","SFO"]
解释: 另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"]。但是它自然排序更大更靠后。
```

**解法：**

```java
class Solution {
    Map<String, PriorityQueue<String>> map = new HashMap<String, PriorityQueue<String>>();
    List<String> itinerary = new LinkedList<String>();

    public List<String> findItinerary(List<List<String>> tickets) {
        for (List<String> ticket : tickets) {
            String src = ticket.get(0), dst = ticket.get(1);
            if (!map.containsKey(src)) {
                map.put(src, new PriorityQueue<String>());
            }
            map.get(src).offer(dst);
        }
        dfs("JFK");
        Collections.reverse(itinerary);
        return itinerary;
    }

    public void dfs(String curr) {
        while (map.containsKey(curr) && map.get(curr).size() > 0) {
            String tmp = map.get(curr).poll();
            dfs(tmp);
        }
        itinerary.add(curr);
    }
}
```

## 28日 机器人能否返回原点 657

在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。

移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。

注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。

**示例 1:**

```
输入: "UD"
输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
```

**示例 2:**

```
输入: "LL"
输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。
```

**解法：**

用x和y分别模拟当前机器人的横纵坐标

```java
class Solution {
    public boolean judgeCircle(String moves) {
        int x = 0, y = 0;
        for (int i = 0; i < moves.length(); i++) {
            char c = moves.charAt(i);
            if (c == 'U') x--;
            else if (c == 'D') x++;
            else if (c == 'L') y--;
            else if (c == 'R') y++;
        }
        return x == 0 && y == 0;
    }
}
```

## 29日 最短回文串 214

给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

**示例 1:**

```
输入: "aacecaaa"
输出: "aaacecaaa"
```

**示例 2:**

```
输入: "abcd"
输出: "dcbabcd"
```

**解法：**

对每一个中心点（字符或两个字符之间），都检测是否回文，对中心点最靠后的回文进行不全，复杂度n平方，侥幸通过。

实际上可以使用kmp中的next数组优化。

```java
class Solution {
    public String shortestPalindrome(String s) {
        int len = s.length();
        int lastPosi = 0;
        for (int i = len - 1; i >= 0; i--) {
            boolean isPalind = true;
            int mid = i / 2;
            if (i % 2 == 0) {
                for (int j = mid - 1; j >= 0; j--) {
                    if (s.charAt(j) != s.charAt(mid + (mid - j))) {
                        isPalind = false;
                        break;
                    }
                }
            } else {
                for (int j = mid; j >= 0; j--) {
                    if (s.charAt(j) != s.charAt(mid + (mid - j) + 1)) {
                        isPalind = false;
                        break;
                    }
                }
            }
            if (isPalind) {lastPosi = i; break;}
        }
        int lastMid = lastPosi / 2;
        int diff;
        if (lastPosi % 2 == 0) {
            diff = (len - lastMid - 1) - lastMid;
        } else {
            diff = (len - lastMid - 1) - (lastMid + 1);
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= diff; i++) {
            sb.append(s.charAt(len - i));
        }
        return sb.toString() + s;
    }
}
```

## 30日 反转字符串中的单词III 557

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

**示例：**

```
输入："Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"
```

**提示：**

- 在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。


**解法：**

先反转单词顺序，再反转整个大字符串的顺序

```java
class Solution {
    public String reverseWords(String s) {
        s = s.trim();
        String[] ss = s.split("\\s+");
        if (ss.length == 0) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = ss.length - 1; i > 0; i--) {
            sb.append(ss[i]).append(" ");
        }
        sb.append(ss[0]);
        return sb.reverse().toString();
    }
}
```

## 31日 钥匙和房间 841

有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。

在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。

最初，除 0 号房间外的其余所有房间都被锁住。

你可以自由地在房间之间来回走动。

如果能进入每个房间返回 true，否则返回 false。

**示例 1：**

```
输入: [[1],[2],[3],[]]
输出: true
解释:  
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。
```

**示例 2：**

```
输入：[[1,3],[3,0,1],[2],[0]]
输出：false
解释：我们不能进入 2 号房间。
```


**提示：**

- 1 <= rooms.length <= 1000
- 0 <= rooms[i].length <= 1000
- 所有房间中的钥匙数量总计不超过 3000。

**解法：**

```java
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        boolean[] canOpen = new boolean[rooms.size()];
        Arrays.fill(canOpen, false);
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(0);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int index = queue.poll();
                canOpen[index] = true;
                for (int n : rooms.get(index)) {
                    if (canOpen[n] == false) queue.offer(n);
                }
            }
        }
        for (boolean b : canOpen) {
            if (!b) return false;
        }
        return true;
    }
}
```

# 九月

## 1日 预测赢家 486

给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。

给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。

**示例 1：**

```
输入：[1, 5, 2]
输出：False
解释：一开始，玩家1可以从1和2中进行选择。
如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。
所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
因此，玩家 1 永远不会成为赢家，返回 False 。
```


**示例 2：**

```
输入：[1, 5, 233, 7]
输出：True
解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233。最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。
```

**提示：**

- 1 <= 给定的数组长度 <= 20.
- 数组里所有分数都为非负数且不会大于 10000000 。
- 如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。

**解法：**

递归法：

```java
class Solution {
    public boolean PredictTheWinner(int[] nums) {
        return total(nums, 0, nums.length - 1, 1) >= 0;
    }

    // 玩家一拿加分，玩家二拿减分，turn为1表示玩家一拿，turn为-1表示玩家二
    private int total(int[] nums, int start, int end, int turn) {
        if (start == end) return nums[start] * turn;
        // 当前玩家选最左，下一个玩家选剩下的
        int scoreStart = nums[start] * turn + total(nums, start + 1, end, -turn);
        // 当前玩家选最右，下一个玩家选剩下的
        int scoreEnd = nums[end] * turn + total(nums, start, end - 1, -turn);
        // 返回当前玩家的选择的最大值，玩家一要让分数尽量高，玩家二要让分数尽量低
        // 如果是第二个玩家 turn为-1，得到的时选左和选右的最小值
        // 如果是第一个玩家 turn为+1，得到的是选左和选右的最大值
        return Math.max(scoreStart * turn, scoreEnd * turn) * turn;
    }
}
```

动态规划：

![](img/75.png)

```java
class Solution {
    public boolean PredictTheWinner(int[] nums) {
        int length = nums.length;
        int[][] dp = new int[length][length];
        for (int i = 0; i < length; i++) {
            dp[i][i] = nums[i];
        }
        for (int i = length - 2; i >= 0; i--) {
            for (int j = i + 1; j < length; j++) {
                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
            }
        }
        return dp[0][length - 1] = 0;
    }
}
```

## 2日 表示数值的字符串 剑指20

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"-1E-16"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。

```java
class Solution {
    public boolean isNumber(String s) {
        s = s.trim();
        if (s.length() == 0) return false;
        if (s.charAt(0) == '+' || s.charAt(0) == '-')
            s = s.substring(1);
        DFA dfa = new DFA();
        for (int i = 0; i < s.length(); i++) {
            dfa.trans(s.charAt(i));
        }
        return dfa.accept();
    }
}

class DFA {
    int state = 0;

    void trans(char c) {
        if (state == 0) {
            if (c >= '0' && c <= '9') state = 2;
            else if (c == '.') state = 3;
            else state = -1;
        }  else if (state == 2) {
            if (c >= '0' && c <= '9') state = 2;
            else if (c == '.') state = 4;
            else if (c == 'e' || c == 'E') state = 5;
            else state = -1;
        } else if (state == 3 && c >= '0' && c <= '9') {
            state = 4;
        } else if (state == 4) {
            if (c >= '0' && c <= '9') state = 4;
            else if (c == 'e' || c == 'E') state = 5;
            else state = -1;
        } else if (state == 5) {
            if (c >= '0' && c <= '9') state = 6;
            else if (c == '+' || c == '-') state = 1;
            else state = -1;
        } else if (state == 1 && c >= '0' && c <= '9') {
            state = 6;
        } else if (state == 6 && c >= '0' && c <= '9') {
            state = 6;
        } else state = -1;
    }

    boolean accept() {
        return state == 2 || state == 4 || state == 6;
    }
}
```

## 3日 N皇后 51

n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

上图为 8 皇后问题的一种解法。

给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

 ![](D:\kejian\leetcode\img\60.png)

**示例：**

```
输入：4
输出：[
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
解释: 4 皇后问题存在两个不同的解法。
```

**提示：**

- 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。


**解法：**

```java
class Solution {
    List<List<String>> res = new ArrayList<>();
    int n;

    public List<List<String>> solveNQueens(int n) {
        String[] track = new String[n];
        for (int i = 0; i < n; i++) {
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < n; j++) sb.append('.');
            track[i] = sb.toString();
        }
        this.n = n;
        backTrack(track, 0);
        return res;
    }

    private void backTrack(String[] track, int row) {
        if (row == n) {
            List<String> list = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                list.add(track[i]);
            }
            res.add(list);
            return;
        }
        for (int col = 0; col < n; col++) {
            if (!isVaild(track, row, col)) continue;
            StringBuilder sb = new StringBuilder(track[row]);
            sb.setCharAt(col, 'Q');
            track[row] = sb.toString();
            backTrack(track, row + 1);
            sb.setCharAt(col, '.');
            track[row] = sb.toString();
        }
    }

    private boolean isVaild(String[] track, int row, int col) {
        for (int i = 0; i < n; i++) {
            if (track[i].charAt(col) == 'Q') return false;
        }
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (track[i].charAt(j) == 'Q') return false;
        }
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (track[i].charAt(j) == 'Q') return false;
        }
        return true;
    }
}
```

## 4日 二叉树的所有路径 257

给定一个二叉树，返回所有从根节点到叶子节点的路径。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```

**解法：**

```java
class Solution {
    List<String> list = new LinkedList<>();

    public List<String> binaryTreePaths(TreeNode root) {
        if (root == null) return list;
        LinkedList<TreeNode> trace = new LinkedList<>();
        backTrace(root, trace);
        return list;
    }

    private void backTrace(TreeNode node, LinkedList<TreeNode> trace) {
        trace.add(node);
        if (node.left == null && node.right == null) {
            list.add(convertToString(trace));
            trace.removeLast(); // 注意这里也要回溯
            return;
        }
        if (node.left != null) backTrace(node.left, trace);
        if (node.right != null) backTrace(node.right, trace);
        trace.removeLast();
    }

    private String convertToString(LinkedList<TreeNode> trace) {
        StringBuilder sb = new StringBuilder(); 
        for (TreeNode node : trace) {
            sb.append(node.val).append("->");
        }
        sb.deleteCharAt(sb.length() - 1);
        sb.deleteCharAt(sb.length() - 1);
        return sb.toString();
    }
}
```

## 5日 第K个排列 60

给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

**说明：**

- 给定 n 的范围是 [1, 9]。
- 给定 k 的范围是[1,  n!]。

**示例 1:**

```
输入: n = 3, k = 3
输出: "213"
```


**示例 2:**

```
输入: n = 4, k = 9
输出: "2314"
```

**解法：**

```java
class Solution {
    public String getPermutation(int n, int k) {
        int[] factorial = new int[n];
        factorial[0] = 1;
        for (int i = 1; i < n; ++i) {
            factorial[i] = factorial[i - 1] * i;
        }

        --k;
        StringBuffer ans = new StringBuffer();
        int[] valid = new int[n + 1];
        Arrays.fill(valid, 1);
        for (int i = 1; i <= n; ++i) {
            int order = k / factorial[n - i] + 1;
            for (int j = 1; j <= n; ++j) {
                order -= valid[j];
                if (order == 0) {
                    ans.append(j);
                    valid[j] = 0;
                    break;
                }
            }
            k %= factorial[n - i];
        }
        return ans.toString();
    }
}
```

## 6日 二叉树的层次遍历II 107

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**例如：**

```
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其自底向上的层次遍历为：

[
  [15,7],
  [9,20],
  [3]
]
```

**解法：**

```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        LinkedList<List<Integer>> res = new LinkedList<>();
        if (root == null) return res;
        Queue<TreeNode> queue = new LinkedList();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> list = new LinkedList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
                list.add(node.val);
            }
            res.push(list);
        }
        return res;
    }
}
```

## 7日 前k个高频元素 347

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

 

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

**提示：**

- 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
- 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。
- 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
- 你可以按任意顺序返回答案。

**解法：**

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();    // 元素-出现次数
        for (int num : nums){   // 构建map
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        // 前 - 后 为小根堆，也就是出现频率少的在堆顶
        PriorityQueue<Integer> heap =
                new PriorityQueue<>((a, b) -> map.get(a) - map.get(b));
        for (int elem : map.keySet()){  // 维持大小为k的堆，选出前k高频的元素
            heap.add(elem);
            if (heap.size() > k){
                heap.poll();    // 堆顶元素出堆
            }
        }
        // 将堆中内容转换为答案
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = heap.poll();
        }
        return res;
    }
}
```

## 8日 组合 77

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

**示例:**

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**解法：**

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> combine(int n, int k) {
        if (n == 0 || k == 0) return res;
        LinkedList<Integer> track = new LinkedList<>();
        backTrack(n, k, 1, track);
        return res;
    }

    private void backTrack(int n,int k,int start,LinkedList<Integer> track){
        if (track.size() == k) {
            res.add(new LinkedList(track));
            return;
        }
        for (int i = start; i <= n; i++) {
            track.push(i);
            backTrack(n, k, i + 1, track);
            track.pop();
        }
    }
}
```

## 9日 数组总和 39

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

**说明：**

- 所有数字（包括 target）都是正整数。
- 解集不能包含重复的组合。 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```


**示例 2：**

```
输入：candidates = [2,3,5], target = 8,
所求解集为：
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

**提示：**

- 1 <= candidates.length <= 30
- 1 <= candidates[i] <= 200
- candidate 中的每个元素都是独一无二的。
- 1 <= target <= 500

**解法：**

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>(); 

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        LinkedList<Integer> list = new LinkedList<>();
        backTrack(0, target, candidates, list, 0);
        return res;
    }

    private void backTrack(int sum, int target, int[] candidates,  LinkedList<Integer> list, int idx) {
        if (sum == target) {
            res.add(new LinkedList<>(list));
            return;
        }
        if (idx == candidates.length) return;
        
        // 跳过当前数字
        backTrack(sum, target, candidates, list, idx + 1);
        // 选择当前数字
        if (target - sum >= candidates[idx]) {
            list.add(candidates[idx]);
            backTrack(sum + candidates[idx], target, candidates, list, idx);
            list.removeLast();
        }
    }
}
```

