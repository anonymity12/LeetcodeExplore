# 七月

## 1日 最长重复子数组718

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

**示例：**

```
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```

**提示：**

- 1 <= len(A), len(B) <= 1000
- 0 <= A[i], B[i] < 100

**解法：**

注意是子数组而不是子序列，子数组是连续的。

```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int[][] dp = new int[A.length + 1][B.length + 1];
        int ans = 0;
        for (int i = 1; i < dp.length; i++) 
            for (int j = 1; j < dp[i].length; j++) {
                if (A[i - 1] == B[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                ans = Math.max(ans, dp[i][j]);
            }
        return ans;
    }
}
```

## 2日 有序矩阵中第K小的元素378

给定一个 `n x n` 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

**示例：**

```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```

**提示：**

- 你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。

**解法：**

使用两次二分

- 在矩阵的最小值到最大值的闭区间内找所求的值
- 通过计算矩阵中有几个数字小于等于mid确定上一点中的二分区间移动，这一步是对矩阵的每一行二分

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int width = matrix[0].length;
        int left = matrix[0][0], right = matrix[matrix.length - 1][width - 1];
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (count(matrix, mid) >= k) {  // 左侧边界的二分
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private int count(int[][] matrix, int target) {
        int width = matrix[0].length, cnt = 0;
        for (int i = 0; i < matrix.length; i++) {
            int left = 0, right = width;
            while(left < right) {   // 右侧边界的二分
                int mid = left + (right - left) / 2;
                if (matrix[i][mid] <= target) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            cnt += left;
        }
        return cnt;
    }
}
```

## 3日 将有序数组转换为二叉搜索树108

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

**示例:**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
      0
     / \
   -3   9
   /   /
 -10  5
```

**解法：**

使用递归，每次都将有序数组中的正中间的数字插入到BST中

```java
class Solution {
    int[] nums;

    public TreeNode sortedArrayToBST(int[] nums) {
        this.nums = nums;
        return recursion(0, nums.length - 1);
    }

    private TreeNode recursion(int left, int right) {
        if (left > right) return null;
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = recursion(left, mid - 1);
        node.right = recursion(mid + 1, right);
        return node;
    }
}
```

## 4日 最长有效括号32

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

**解法：**

使用栈检测括号，给不正确的括号值标志位，求连续无标志位的最大值

```java
class Solution {
    public int longestValidParentheses(String s) {
        Deque<Integer> stack = new LinkedList<>();
        boolean[] flags = new boolean[s.length()]; // true为错误的括号
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') stack.push(i);
            else {
                if (stack.isEmpty()) flags[i] = true;
                else stack.pop();
            }
        }
        while (!stack.isEmpty()) {
            flags[stack.pop()] = true;
        }
        int maxn = 0, len = 0;
        for (int i = 0; i < flags.length; i++) {
            if (flags[i] == false) len++;
            else {
                maxn = Math.max(len, maxn);
                len = 0;
            }
        }
        return Math.max(len, maxn);
    }
}
```

## 5日 通配符匹配44

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

两个字符串完全匹配才算匹配成功。

**说明:**

- s 可能为空，且只包含从 a-z 的小写字母。
- p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

**示例 3:**

```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

**示例 4:**

```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

**解法：**

状态：s 的前 i 个字符是否能和 p 的前 i 个字符匹配

转移：![](img/54.png)

base case：`dp[0][0] = true`， `dp[i][开头的若干个星号] = true`注意只有开头的连续星号才需要置为true，字母后面的星号就不需要了。

以示例4为例的 dp 数组：

|      | ""   | *    | a    | *    | b    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| ""   | T    | T    |      |      |      |
| a    |      | T    | T    | T    |      |
| d    |      | T    |      | T    |      |
| c    |      | T    |      | T    |      |
| e    |      | T    |      | T    |      |
| b    |      | T    |      | T    | T    |

```java
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        for (int i = 1; i <= p.length(); i++) {
            if (p.charAt(i - 1) == '*') dp[0][i] = true;
            else break;
        }
        dp[0][0] = true;
        
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= p.length(); j++) {
                if (p.charAt(j - 1) == '?') dp[i][j] = dp[i - 1][j - 1];
                else if (p.charAt(j - 1) == '*') 
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j - 1] && s.charAt(i - 1) == p.charAt(j - 1);
            }
        }
        return dp[s.length()][p.length()];
    }    
}
```

## 6日 不同路径II63

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![](img/55.png)

网格中的障碍物和空位置分别用 1 和 0 来表示。

**说明：**m 和 n 的值均不超过 100。

**示例 1:**

```
  输入:
  [
    [0,0,0],
    [0,1,0],
    [0,0,0]
  ]
  输出: 2
  解释:
  3x3 网格的正中间有一个障碍物。
  从左上角到右下角一共有 2 条不同的路径：
  1. 向右 -> 向右 -> 向下 -> 向下
  2. 向下 -> 向下 -> 向右 -> 向右
```

 **解法：**

首先想到回溯：

```java
class Solution {
    int res;

    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid.length == 0) return 0;
        if (obstacleGrid[0][0] == 1) return 0;
        backTrack(obstacleGrid, 0, 0);
        return res;
    }
    
    private void backTrack(int[][] grid, int i, int j) {
        if (i == grid.length-1 && j == grid[0].length-1 && grid[i][j] != 1) {
            res++;
            return;
        }
        if (i < grid.length - 1 && grid[i + 1][j] != 1) {
            i = i + 1;
            backTrack(grid, i, j);
            i = i - 1;
        }
        if (j < grid[0].length - 1 && grid[i][j + 1] != 1) {
            j = j + 1;
            backTrack(grid, i, j);
            j = j - 1;
        }
    }
}
```

然而超时，改用dp，状态是`dp[i][j] = 到答i行j列的路线个数`

转移：![](img/56.png)

实现（通过）：

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int dp[][] = new int[obstacleGrid.length+1][obstacleGrid[0].length+1];
        dp[0][1] = 1;
        for (int i = 1; i < dp.length; i++)
            for (int j = 1; j < dp[0].length; j++) {
                if (obstacleGrid[i - 1][j - 1] == 1) dp[i][j] = 0;
                else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        return dp[obstacleGrid.length][obstacleGrid[0].length];
    }
}
```

## 7日 路径总和112

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:** 
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

**解法：**

使用递归

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) return false;
        return recursion(root, sum);
    }

    private boolean recursion(TreeNode root, int sum) {
        if (root == null && sum == 0) return true;
        if (root == null && sum != 0) return false;
        if (root.left == null && root.right == null) return root.val == sum;
        int s = sum - root.val;
        return hasPathSum(root.left, s) || hasPathSum(root.right, s);
    }
}
```

## 8日 跳水版 面试题16.11

你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。

返回的长度需要从小到大排列。

**示例：**

```
输入：
shorter = 1
longer = 2
k = 3
输出： {3,4,5,6}
```

**提示：**

- 0 < shorter <= longer
- 0 <= k <= 100000

**解法：**

边界条件：

- k == 0时 返回空数组
- longer == shorter时 返回的数组只有一个元素，就是`shorter * k`。

只需要考虑shorter，shorter可以是`0 ~ k`个，就是`k + 1`种情况。

```java
class Solution {
    public int[] divingBoard(int shorter, int longer, int k) {
        if (k == 0) return new int[0];
        if (shorter == longer) {
            int[] arr = new int[1];
            arr[0] = shorter * k;
            return arr;
        }
        int[] res = new int[k + 1];
        for (int i = 0; i <= k ; i++) {
            res[i] = longer * i + shorter * (k - i);
        }
        return res;
    }
}
```

## 9日 恢复空格 面试题17.13

哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子"I reset the computer. It still didn’t boot!"已经变成了"iresetthecomputeritstilldidntboot"。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。

**注意：**本题相对原题稍作改动，只需返回未识别的字符数

**示例：**

```
输入：
dictionary = ["looked","just","like","her","brother"]
sentence = "jesslookedjustliketimherbrother"
输出： 7
解释： 断句后为"jess looked just like tim her brother"，共7个未识别字符。
```

**提示：**

- 0 <= len(sentence) <= 1000
- dictionary中总字符数不超过 150000。
- 你可以认为dictionary和sentence中只包含小写字母。

**解法：**

状态：dp[i] 是sentence 字符串的 [0, i) 范围内匹配不了的字符数

转移：用 sentence 字符串的[j, i)子串和字典匹配，j 的范围是 [0, i)

- 如果不匹配，增加了一个匹配不了的字符 `dp[i] = dp[i - 1]  + 1`。先考虑这种情况
- 如果匹配，则考虑是否值得匹配`dp[i] = Math.max(dp[j], dp[i])`。

```java
class Solution {
    public int respace(String[] dictionary, String sentence) {
        Set<String> set = new HashSet(Arrays.asList(dictionary));
        int n = sentence.length();
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1] + 1;
            for (int j = 0; j < i; j++) {
                if (set.contains(sentence.substring(j, i))) {
                    dp[i] = Math.min(dp[i], dp[j]);
                }
            }
        }
        return dp[n];
    }
}
```

时间复杂度为O($n^2$) 832ms，可以使用字典树优化，优化后复杂度仍为O($n^2$) ，但执行时间缩短到16ms，原因是在内层循环中增加了中途退出循环的可能，这正是字典树的作用，这里的字典树是倒序的。

```java
class Tire {
    public Tire[] next;
    public boolean isEnd;

    public Tire() {
        next = new Tire[26];
        isEnd = false;
    }

    public void insert(String s) {
        Tire curPos = this;

        for (int i = s.length() - 1; i >= 0; i--) {
            int t = s.charAt(i) - 'a';
            if (curPos.next[t] == null) {
                curPos.next[t] = new Tire();
            }
            curPos = curPos.next[t];
        }
        curPos.isEnd = true;
    }
}

class Solution {
    public int respace(String[] dictionary, String sentence) {
        Tire root = new Tire();
        for (String s : dictionary) {
            root.insert(s);
        }
        int n = sentence.length();
        int[] dp = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i - 1] + 1;
            Tire curPos = root;
            for (int j = i; j >= 1; j--) {
                int t = sentence.charAt(j - 1) - 'a';
                if (curPos.next[t] == null) break;  // 匹配不到
                else if (curPos.next[t].isEnd)    // 匹配到
                	// 注意这里是j-1, 匹配到的单词第一个字符在j，j-1表这个单词之前
                    dp[i] = Math.min(dp[j - 1], dp[i]);
                else if (dp[i] == 0) break;         // 完全匹配
                curPos = curPos.next[t];
            }
        }
        return dp[n];
    }
}
```

## 10日 最佳买卖股票时机含冷冻期309

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**解法：**

dp，第一维表示第几天，第二维表示买入或卖出。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 0) return 0;
        int[][] dp = new int[prices.length][2];
        dp[0][1] = -prices[0];
        for (int i = 1; i < dp.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            if (i >= 2)
                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
            else 
                dp[i][1] = Math.max(dp[i - 1][1], 0 - prices[i]);
        }
        return dp[dp.length - 1][0];
    }
}
```

## 11日 计算右侧小于当前元素的个数315

给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。

**示例:**

```
输入: [5,2,6,1]
输出: [2,1,1,0] 
解释:
5 的右侧有 2 个更小的元素 (2 和 1).
2 的右侧仅有 1 个更小的元素 (1).
6 的右侧有 1 个更小的元素 (1).
1 的右侧有 0 个更小的元素.
```

**解法：**

使用离散化的树状数组

```java
class Solution {
    private int[] a;
    private int[] c;

    public List<Integer> countSmaller(int[] nums) {
        List<Integer> res = new LinkedList<>();
        discretization(nums);
        this.c = new int[a.length];
        for (int i = nums.length - 1; i >= 0; i--) {
            int idx = getIndex(nums[i]);
            res.add(getSum(idx - 1));
            update(idx);
        }
        Collections.reverse(res);
        return res;
    }

    private void discretization(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int n : nums) set.add(n);
        this.a = new int[set.size() + 1];
        int index = 1;
        for (Integer n : set) a[index++] = n.intValue();
        Arrays.sort(a, 1, a.length);
    }

    private int getIndex(int num) {
        return Arrays.binarySearch(a, 1, a.length, num);
    }

    private int lowBit(int x) {
        return x & (-x);
    }

    private int getSum(int n) {
        int res = 0;
        while (n > 0) {
            res += c[n];
            n -= lowBit(n);
        }
        return res;
    }

    private void update(int idx) {
        while (idx < c.length) {
            c[idx]++;
            idx += lowBit(idx);
        }
    }
}
```

## 12日 地下城游戏174

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

-2 (K)	-3	3
-5	-10	1
10	30	-5 (P)


说明:

- 骑士的健康点数没有上限。

- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。


**解法：**

反向dp，`dp[i][j]`就是骑士在第 i 行 j 列所需要的最小hp，所以这个值是不能小于 1 的。

初值，其实到公主房间前的最低HP

```java
dp[row - 1][col - 1] = Math.max(1 - dungeon[row-1][col-1], 1);
```

对于最后一列和最后一行，只能仅向下或仅向右，所以转移是：

```java
for (int i = row - 2; i >= 0; i--)
    dp[i][col - 1] = Math.max(dp[i+1][col-1] - dungeon[i][col-1], 1);
for (int i = col - 2; i >= 0; i--)
    dp[row - 1][i] = Math.max(dp[row-1][i+1] - dungeon[row-1][i], 1);
for (int i = row - 2; i >= 0; i--)
```

其他格子的转移就是选去右边或去下边需要的最小HP，并且减去这一格需要的HP

```java
for (int i = row - 2; i >= 0; i--)
    for (int j = col - 2; j >= 0; j--) {
        dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1])-dungeon[i][j];
        if (dp[i][j] < 1) dp[i][j] = 1;
    }
```

完整代码：

```java
class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        int row = dungeon.length, col = dungeon[0].length;
        int[][] dp = new int[row][col];
        dp[row - 1][col - 1] = Math.max(1 - dungeon[row-1][col-1], 1);
        for (int i = row - 2; i >= 0; i--)
            dp[i][col - 1] = Math.max(dp[i+1][col-1] - dungeon[i][col-1], 1);
        for (int i = col - 2; i >= 0; i--)
            dp[row - 1][i] = Math.max(dp[row-1][i+1] - dungeon[row-1][i], 1);
        for (int i = row - 2; i >= 0; i--)
            for (int j = col - 2; j >= 0; j--) {
                dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1])-dungeon[i][j];
                if (dp[i][j] < 1) dp[i][j] = 1;
            }
        return dp[0][0];
    }
}
```

## 13日 两个数组的交集II 350

给定两个数组，编写一个函数来计算它们的交集。

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**示例 2:**

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

**说明：**

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
- 我们可以不考虑输出结果的顺序。

**进阶：**

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 nums1 的大小比 nums2 小很多，哪种方法更优？
- 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

**解法：**

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        // 将nums1的 数字-出现次数 装入map
        Map<Integer, Integer> map = new HashMap<>();
        // getOrdefault(key, defaultValue)
        for (int num : nums1)
            map.put(num, map.getOrDefault(num, 0) + 1);

        // 遍历nums2，每找到一个： 1加入结果集，2在map中value - 1
        ArrayList<Integer> list = new ArrayList<>();
        for (int num : nums2)
            if (map.containsKey(num) && map.get(num) > 0) {
                list.add(num);
                map.put(num, map.get(num) - 1);
            }

        // 返回结果
        int[] res = new int[list.size()];
        for (int i = 0; i < list.size(); i++)
            res[i] = list.get(i);
        return res;
    }
}
```

## 14日 三角形最小路径和 120

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 `下标` 与 `上一层结点下标` 相同或者等于 `上一层结点下标 + 1` 的两个结点。

例如，给定三角形：

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

**说明：**

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

**解法：**

`dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + 三角形[i][j]`再优化成一维的dp数组

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        if (triangle.size() == 0) return 0;
        int[] dp = new int[triangle.size()];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = triangle.get(0).get(0);
        for (int i = 1; i < triangle.size(); i++) {
            for (int j = i; j >= 0; j--) {
                if (j == 0) dp[j] = dp[j] + triangle.get(i).get(j);
                else dp[j] = Math.min(dp[j], dp[j - 1]) 
                        + triangle.get(i).get(j);
            }
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < dp.length; i++) {
            res = Math.min(res, dp[i]);
        }
        return res;
    }
}
```

## 15日 不同的二叉搜索树 96

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

**解法：**

假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，...，n为根节点，当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，所以可得`G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)`。

```java
class Solution {
    public int numTrees(int n) {
        if (n == 0) return 0;
        int[] dp = new int[n + 1];
        dp[0] = dp[1] = 1;
        for (int i = 2; i < dp.length; i++) {
            for (int j = 0; j < i; j++) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        return dp[n];
    }
}
```

## 16日 判断二分图 785

给定一个无向图graph，当这个图为二分图时返回true。

如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。

graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。

**示例 1:**

```
输入: [[1,3], [0,2], [1,3], [0,2]]
输出: true
解释: 
无向图如下:
0----1
|    |
|    |
3----2
我们可以将节点分成两组: {0, 2} 和 {1, 3}。
```

**示例 2:**

```
输入: [[1,2,3], [0,2], [0,1,3], [0,2]]
输出: false
解释: 
无向图如下:
0----1
| \  |
|  \ |
3----2
我们不能将节点分割成两个独立的子集。
```

**注意:**

- graph 的长度范围为 [1, 100]。
- graph[i] 中的元素的范围为 [0, graph.length - 1]。
- graph[i] 不会包含 i 或者有重复的值。
- 图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。

**解法：**

给初始结点标红色，红色的相邻结点标绿色，绿色的相邻标红色，如果颜色冲突，则不是二分图。

注意题目中的图不一定联通，所以需要多次bfs

```java
class Solution {
    private int color[];    // 0代表位访问到 1代表涂红 2代表涂绿
    private boolean isVaild;

    public boolean isBipartite(int[][] graph) {
        this.color = new int[graph.length];
        isVaild = true;
        for (int i = 0; i < graph.length; i++) {
            if (color[i] == 0) dfs(i, 1, graph);
        }
        return isVaild;
    }

    private void dfs(int node, int c, int[][] graph) {
        color[node] = c;
        int neighborColor = (c == 1) ? 2 : 1;
        for (int neighbor : graph[node]) {
            if (color[neighbor] == 0) {
                dfs(neighbor
                , neighborColor, graph);
                if (!isVaild) return;
            }
            else if (color[neighbor] != neighborColor) {
                isVaild = false;
                return;
            }
        }
    }
}
```

## 17日 搜索插入位置 35

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**

```
输入: [1,3,5,6], 5
输出: 2
```

**示例 2:**

```
输入: [1,3,5,6], 2
输出: 1
```

**示例 3:**

```
输入: [1,3,5,6], 7
输出: 4
```

**示例 4:**

```
输入: [1,3,5,6], 0
输出: 0
```

**解法：**

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target)
                right = mid - 1;
            else if (nums[mid] < target)
                left = mid + 1;
        }
        return left;
    }
}
```

## 18日 交错字符串 97

给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。

**示例 1:**

```
输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出: true
```

**示例 2:**

```
输入: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
输出: false
```

**解法：**

递归/搜索

```java
class Solution {
    String s1, s2, s3;

    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        this.s1 = s1;
        this.s2 = s2;
        this.s3 = s3;
        return recursion(0,0,0);
    }

    private boolean recursion(int i1, int i2, int i3) {
        if (i1 == s1.length() && i2 == s2.length() && i3 == s3.length())
            return true;
        boolean res = false;
        if (i1 < s1.length() && s1.charAt(i1) == s3.charAt(i3) && recursion(i1 + 1, i2, i3 + 1)) return true;
        if (i2 < s2.length() && s2.charAt(i2) == s3.charAt(i3) && recursion(i1, i2 + 1, i3 + 1)) return true;
        return res;
    }
}
```

记忆化：Boolean可以有三种状态true false null

```java
class Solution {
    String s1, s2, s3;
    Boolean[][] dp;

    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        this.s1 = s1;
        this.s2 = s2;
        this.s3 = s3;
        this.dp = new Boolean[s1.length() + 1][s2.length() + 1];
        return recursion(0,0,0);
    }

    private boolean recursion(int i1, int i2, int i3) {
        if (i1 == s1.length() && i2 == s2.length() && i3 == s3.length())
            return true;
        if (dp[i1][i2] != null) return dp[i1][i2];
        boolean res = false;
        if (i1 < s1.length() && s1.charAt(i1) == s3.charAt(i3) && recursion(i1 + 1, i2, i3 + 1)) {
            dp[i1][i2] = true;
            return true;           
        }
        if (i2 < s2.length() && s2.charAt(i2) == s3.charAt(i3) && recursion(i1, i2 + 1, i3 + 1)) {
            dp[i1][i2] = true;
            return true;
        }
        dp[i1][i2] = false;
        return res;
    }
}
```

动态规划：

状态：`dp[i][j]`就是 s1 的前 i 个字符和 s2 的前 j 个字符，能否交错组成 s3 的前 i + j 个字符

转移：![](img/68.png)

basecase: `dp[0][0] = true` 空串和空串能交错组成空串

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
        dp[0][0] = true;
        for (int i = 0; i <= s1.length(); i++)
            for (int j = 0; j <= s2.length(); j++) {
                int i3 = i + j - 1;
                if (i != 0) 
                    dp[i][j] |= dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i3);
                if (j != 0) 
                    dp[i][j] |= dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i3);
            }
        return dp[s1.length()][s2.length()];
    }
}
```

## 19日 戳气球 312

有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。

求所能获得硬币的最大数量。

**说明:**

- 你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。
- 0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100

**示例:**

```
输入: [3,1,5,8]
输出: 167 
解释: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
```

**解法：**

每戳破一个气球，nums数组就会改变，看似子问题不独立，但是，求最值问题一定可以穷举得到结果。

状态：i 和 j 本身就是状态，表示起始的气球和中止的气球。

转移：戳破 i 和 j 之间即（i，j）中的一个气球。

`dp[i][j]`表示把 i ，j 开区间内的所有气球戳爆获得的最大钱数。题目中说可以假设`nums[-1] = nums[n] = 1`，所以`dp[-1][n]`就是最终答案。

状态转移方程：`dp[i][j] = dp[i][k] + dp[k][j] + nums[i] * nums[j] * nums[k]`。

只需要用到上三角矩阵，而且是从下往上dp的。

![](E:/kejian/知识总结/leetcode/img/46.jpeg)

```java
class Solution {
    public int maxCoins(int[] nums) {
        int len = nums.length;
        int[] points = new int[len + 2];
        points[0] = points[len + 1] = 1;
        for (int i = 1; i <= len; i++) points[i] = nums[i - 1];
        int[][] dp = new int[len + 2][len + 2];
        for (int i = len; i >= 0; i--) {
            for (int j = i + 1; j < len + 2; j++) {
                for (int k = i + 1; k < j; k++) {
                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + points[i] * points[k] * points[j]); 
                }
            }
        }
        return dp[0][len + 1];
    }
}
```

## 20日 两数之和II-输入有序数组167

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

**说明:**

- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例:**

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**解法：**

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int[] res = new int[2];
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            if (numbers[left] + numbers[right] < target) left++;
            else if (numbers[left] + numbers[right] > target) right--;
            else {
                res[0] = left + 1;
                res[1] = right + 1;
                break;
            }
        }
        return res;
    }
}
```

## 21日 不同的二叉搜索树II 95

给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。

**示例：**

```
输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

**提示：**

- 0 <= n <= 8

**解法：**

注意这不是回溯，是递归，链表定义在每一层递归的开头。

```java
class Solution {
    public List<TreeNode> generateTrees(int n) {
        if (n == 0) return new LinkedList<TreeNode>();
        return recursion(1, n);
    }

    // 求[start, end]范围内所有节点构造出的所有子树
    private List<TreeNode> recursion(int start, int end) {
        // 当前子树的所有可能的排列
        List<TreeNode> allTrees = new LinkedList<>();
        if (start > end) {
            allTrees.add(null); // 这一句是必须的，否则创建不了结点
            return allTrees;
        }

        for (int i = start; i <= end; i++) {
            // 当前子树的左子树和右子树的所有可能的排列
            List<TreeNode> leftTrees = recursion(start, i - 1);
            List<TreeNode> rightTrees = recursion(i + 1, end);

            // 构建出当前子树所有可能的排列
            for (TreeNode left : leftTrees)
                for (TreeNode right : rightTrees) {
                    TreeNode node = new TreeNode(i);
                    node.left = left;
                    node.right = right;
                    allTrees.add(node);
                }
        }

        return allTrees;
    }
}
```

## 22日 旋转数组的最小数字 剑指offer11

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

**示例 1：**

```
输入：[3,4,5,1,2]
输出：1
```

**示例 2：**

```
输入：[2,2,2,0,1]
输出：0
```

**解法：**

```java
class Solution {
    public int minArray(int[] numbers) {
        int left = 0, right = numbers.length - 1;
        while (numbers[left] >= numbers[right]) {
            if (left == right - 1) {
                return numbers[right];
            }
            int mid = left + (right - left) / 2;
            if (numbers[left]==numbers[right]&&numbers[left]==numbers[mid]) {
                return inorderSearch(numbers, left, right);
            }
            if (numbers[mid] >= numbers[left])
                left = mid;
            else if (numbers[mid] <= numbers[right])
                right = mid; 
        }
        return numbers[left];
    }

    private int inorderSearch(int[] numbers, int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            if (numbers[i] < numbers[i - 1]) {
                return numbers[i];
            }
        }
        return numbers[left];
    }
}
```

## 23日 最小路径和64

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

**示例:**

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

**解法：**

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid.length == 0 || grid[0].length == 0) return 0;
        int row = grid.length, col = grid[0].length;
        for (int i = 1; i < row; i++)
            grid[i][0] += grid[i - 1][0];
        for (int i = 1; i < col; i++)
            grid[0][i] += grid[0][i - 1];
        for (int i = 1; i < row; i++)
            for (int j = 1; j < col; j++) {
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        return grid[row - 1][col - 1];
    }
}
```

## 24日 除数博弈

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

选出任一 x，满足 0 < x < N 且 N % x == 0 。
用 N - x 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

**示例 1：**

```
输入：2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
```

**示例 2：**

```
输入：3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
```

**提示：**

- 1 <= N <= 1000

**解法：**

多列几项找规律可知，偶数先手必胜

```java
class Solution {
    public boolean divisorGame(int N) {
        if (N % 2 == 0) return true;
        return false;
    }
}
```

