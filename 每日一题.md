# 七月

## 1日 最长重复子数组718

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

**示例：**

```
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```

**提示：**

- 1 <= len(A), len(B) <= 1000
- 0 <= A[i], B[i] < 100

**解法：**

注意是子数组而不是子序列，子数组是连续的。

```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int[][] dp = new int[A.length + 1][B.length + 1];
        int ans = 0;
        for (int i = 1; i < dp.length; i++) 
            for (int j = 1; j < dp[i].length; j++) {
                if (A[i - 1] == B[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                ans = Math.max(ans, dp[i][j]);
            }
        return ans;
    }
}
```

## 2日 有序矩阵中第K小的元素378

给定一个 `n x n` 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

**示例：**

```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```

**提示：**

- 你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。

**解法：**

使用两次二分

- 在矩阵的最小值到最大值的闭区间内找所求的值
- 通过计算矩阵中有几个数字小于等于mid确定上一点中的二分区间移动，这一步是对矩阵的每一行二分

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int width = matrix[0].length;
        int left = matrix[0][0], right = matrix[matrix.length - 1][width - 1];
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (count(matrix, mid) >= k) {  // 左侧边界的二分
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private int count(int[][] matrix, int target) {
        int width = matrix[0].length, cnt = 0;
        for (int i = 0; i < matrix.length; i++) {
            int left = 0, right = width;
            while(left < right) {   // 右侧边界的二分
                int mid = left + (right - left) / 2;
                if (matrix[i][mid] <= target) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            cnt += left;
        }
        return cnt;
    }
}
```

## 3日 将有序数组转换为二叉搜索树108

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

**示例:**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
      0
     / \
   -3   9
   /   /
 -10  5
```

**解法：**

使用递归，每次都将有序数组中的正中间的数字插入到BST中

```java
class Solution {
    int[] nums;

    public TreeNode sortedArrayToBST(int[] nums) {
        this.nums = nums;
        return recursion(0, nums.length - 1);
    }

    private TreeNode recursion(int left, int right) {
        if (left > right) return null;
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = recursion(left, mid - 1);
        node.right = recursion(mid + 1, right);
        return node;
    }
}
```

## 4日 最长有效括号32

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

**解法：**

使用栈检测括号，给不正确的括号值标志位，求连续无标志位的最大值

```java
class Solution {
    public int longestValidParentheses(String s) {
        Deque<Integer> stack = new LinkedList<>();
        boolean[] flags = new boolean[s.length()]; // true为错误的括号
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') stack.push(i);
            else {
                if (stack.isEmpty()) flags[i] = true;
                else stack.pop();
            }
        }
        while (!stack.isEmpty()) {
            flags[stack.pop()] = true;
        }
        int maxn = 0, len = 0;
        for (int i = 0; i < flags.length; i++) {
            if (flags[i] == false) len++;
            else {
                maxn = Math.max(len, maxn);
                len = 0;
            }
        }
        return Math.max(len, maxn);
    }
}
```