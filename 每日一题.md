# 七月

## 1日 最长重复子数组718

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

**示例：**

```
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。
```

**提示：**

- 1 <= len(A), len(B) <= 1000
- 0 <= A[i], B[i] < 100

**解法：**

注意是子数组而不是子序列，子数组是连续的。

```java
class Solution {
    public int findLength(int[] A, int[] B) {
        int[][] dp = new int[A.length + 1][B.length + 1];
        int ans = 0;
        for (int i = 1; i < dp.length; i++) 
            for (int j = 1; j < dp[i].length; j++) {
                if (A[i - 1] == B[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                ans = Math.max(ans, dp[i][j]);
            }
        return ans;
    }
}
```

## 2日 有序矩阵中第K小的元素378

给定一个 `n x n` 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

**示例：**

```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```

**提示：**

- 你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。

**解法：**

使用两次二分

- 在矩阵的最小值到最大值的闭区间内找所求的值
- 通过计算矩阵中有几个数字小于等于mid确定上一点中的二分区间移动，这一步是对矩阵的每一行二分

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int width = matrix[0].length;
        int left = matrix[0][0], right = matrix[matrix.length - 1][width - 1];
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (count(matrix, mid) >= k) {  // 左侧边界的二分
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }

    private int count(int[][] matrix, int target) {
        int width = matrix[0].length, cnt = 0;
        for (int i = 0; i < matrix.length; i++) {
            int left = 0, right = width;
            while(left < right) {   // 右侧边界的二分
                int mid = left + (right - left) / 2;
                if (matrix[i][mid] <= target) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            cnt += left;
        }
        return cnt;
    }
}
```

## 3日 将有序数组转换为二叉搜索树108

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

**示例:**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
      0
     / \
   -3   9
   /   /
 -10  5
```

**解法：**

使用递归，每次都将有序数组中的正中间的数字插入到BST中

```java
class Solution {
    int[] nums;

    public TreeNode sortedArrayToBST(int[] nums) {
        this.nums = nums;
        return recursion(0, nums.length - 1);
    }

    private TreeNode recursion(int left, int right) {
        if (left > right) return null;
        int mid = left + (right - left) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = recursion(left, mid - 1);
        node.right = recursion(mid + 1, right);
        return node;
    }
}
```

## 4日 最长有效括号32

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

**解法：**

使用栈检测括号，给不正确的括号值标志位，求连续无标志位的最大值

```java
class Solution {
    public int longestValidParentheses(String s) {
        Deque<Integer> stack = new LinkedList<>();
        boolean[] flags = new boolean[s.length()]; // true为错误的括号
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') stack.push(i);
            else {
                if (stack.isEmpty()) flags[i] = true;
                else stack.pop();
            }
        }
        while (!stack.isEmpty()) {
            flags[stack.pop()] = true;
        }
        int maxn = 0, len = 0;
        for (int i = 0; i < flags.length; i++) {
            if (flags[i] == false) len++;
            else {
                maxn = Math.max(len, maxn);
                len = 0;
            }
        }
        return Math.max(len, maxn);
    }
}
```

## 5日 通配符匹配44

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

两个字符串完全匹配才算匹配成功。

**说明:**

- s 可能为空，且只包含从 a-z 的小写字母。
- p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

**示例 3:**

```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

**示例 4:**

```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

**解法：**

状态：s 的前 i 个字符是否能和 p 的前 i 个字符匹配

转移：![](img/54.png)

base case：`dp[0][0] = true`， `dp[i][开头的若干个星号] = true`注意只有开头的连续星号才需要置为true，字母后面的星号就不需要了。

以示例4为例的 dp 数组：

|      | ""   | *    | a    | *    | b    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| ""   | T    | T    |      |      |      |
| a    |      | T    | T    | T    |      |
| d    |      | T    |      | T    |      |
| c    |      | T    |      | T    |      |
| e    |      | T    |      | T    |      |
| b    |      | T    |      | T    | T    |

```java
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        for (int i = 1; i <= p.length(); i++) {
            if (p.charAt(i - 1) == '*') dp[0][i] = true;
            else break;
        }
        dp[0][0] = true;
        
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= p.length(); j++) {
                if (p.charAt(j - 1) == '?') dp[i][j] = dp[i - 1][j - 1];
                else if (p.charAt(j - 1) == '*') 
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j - 1] && s.charAt(i - 1) == p.charAt(j - 1);
            }
        }
        return dp[s.length()][p.length()];
    }    
}
```

## 6日 不同路径II63

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

![](img/55.png)

网格中的障碍物和空位置分别用 1 和 0 来表示。

**说明：**m 和 n 的值均不超过 100。

**示例 1:**

```
  输入:
  [
    [0,0,0],
    [0,1,0],
    [0,0,0]
  ]
  输出: 2
  解释:
  3x3 网格的正中间有一个障碍物。
  从左上角到右下角一共有 2 条不同的路径：
  1. 向右 -> 向右 -> 向下 -> 向下
  2. 向下 -> 向下 -> 向右 -> 向右
```

 **解法：**

首先想到回溯：

```java
class Solution {
    int res;

    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid.length == 0) return 0;
        if (obstacleGrid[0][0] == 1) return 0;
        backTrack(obstacleGrid, 0, 0);
        return res;
    }
    
    private void backTrack(int[][] grid, int i, int j) {
        if (i == grid.length-1 && j == grid[0].length-1 && grid[i][j] != 1) {
            res++;
            return;
        }
        if (i < grid.length - 1 && grid[i + 1][j] != 1) {
            i = i + 1;
            backTrack(grid, i, j);
            i = i - 1;
        }
        if (j < grid[0].length - 1 && grid[i][j + 1] != 1) {
            j = j + 1;
            backTrack(grid, i, j);
            j = j - 1;
        }
    }
}
```

然而超时，改用dp，状态是`dp[i][j] = 到答i行j列的路线个数`

转移：![](img/56.png)

实现（通过）：

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int dp[][] = new int[obstacleGrid.length+1][obstacleGrid[0].length+1];
        dp[0][1] = 1;
        for (int i = 1; i < dp.length; i++)
            for (int j = 1; j < dp[0].length; j++) {
                if (obstacleGrid[i - 1][j - 1] == 1) dp[i][j] = 0;
                else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        return dp[obstacleGrid.length][obstacleGrid[0].length];
    }
}
```

## 7日 路径总和112

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:** 
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

**解法：**

使用递归

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) return false;
        return recursion(root, sum);
    }

    private boolean recursion(TreeNode root, int sum) {
        if (root == null && sum == 0) return true;
        if (root == null && sum != 0) return false;
        if (root.left == null && root.right == null) return root.val == sum;
        int s = sum - root.val;
        return hasPathSum(root.left, s) || hasPathSum(root.right, s);
    }
}
```

